# 浏览器的缓存机制

    原理: 根据 "http报文缓存标识" 进行的
         http请求报文: request 只有post报文主体, 跟多的信息可以放在header中
         http响应报文: response
    http缓存的请求头
      1. cache-control: 请求头/响应头 | http缓存的最高指令
         no-store: 所有内容都不缓存
         no-cache: 是否使用最新的缓存
         max-age=x: 请求缓存后x秒不在请求
         s-maxage=x: 代理服务器请求缓存后x秒不在请求
         public: 客户端和代理服务器都可缓存
         private: 只有客户端可以缓存
      2. expires 响应头,资源过期时间(服务器提供)
      3. last-modified 响应头,资源最新修改时间(服务端 >> 浏览器) [3.4.做对比,计算时间]
      4. if-modified-since 请求头,资源最新修改时间(浏览器 >> 服务端) [3.4.做对比,计算时间]
      5. etag 资源标识(服务端 >> 浏览器)
      6. if-none-match 资源标识(浏览器 >> 服务端)

# 正常的请求顺序

    1.浏览器发起http请求,初次没有缓存标识
    2.向服务端发起http请求,返回请求的结果和缓存的标识
    3.再次发起http请求,携带缓存标识,将内容写入浏览器中

# 为什么使用缓存

    1. 缓解服务器压力, 并发量
    2. 节省流量, 重复性的内容较多
    3. 用户体验, 不需要每次都请求

# OIS 模型

    应用层: 操作层,和用户进行交互
    表示层: 展示文字,图片等数据
    会话层: cookie,session等
    传输层: TCP/UDP,三次握手
    网络层: 对数据进行封装,四次挥手
    数据层: 使用MAC地址进行封装
    物理层: 将数据以光电信号进行传输

# 三次握手

    客户端: 请求传输数据
    服务端: 同意
    客户端: 好的,开始请求

# 四次挥手

    服务端: 我要断开了
    客户端: 稍等,等我处理完任务
    服务端: 好的,我等你
    客户端: 可以断开了

# http1.0

    1. 最早的协议标准
    2. 浏览器和服务器之间建立短暂连接, 每次请求创建TCP, 完成之后断开连接
    3. "请求-相应"一一对应, 效果不好

# http1.1

    1. 对http1.0做了优化, 可以持久化连接
    2. 一个TCP可以包含多个请求
    3. 优化内容:
       缓存的处理
       带宽优化, 网络连接优化
       错误通知的管理
       消息在网络中发送
       安全性和完整性

# http2.0

    1. 兼容http1.1的原有功能
    2. 充分挖掘tcp协议的能力, 更少的tcp请求
    3. 向服务器发送的request请求模型没有变化
    4. 协议写法没有变化, 和http1.1一样
    5. 可以通过代理的方式, 将http1.1升级为http2.0
    6. 不识别http2.0的话, 可以将协议降为http1.1

    [压缩头部, 二进制分帧]
