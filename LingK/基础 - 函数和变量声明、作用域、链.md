# var let const

    1. var会变量提升, let和const不会.
    2. let和const是块作用域.
    3. let和const不允许重复声明, 会报错阻塞.
    4. let和const在声明之前调用, 会抛出错误.(封闭作用域).
       Can't access xxx before initialization (暂时性死区)
    5. const是一个只读常量, 设置后无法修改; 如果是引用对象, 无法修改引用, 可以修改内容.

    暂时性死区: 声明的时候, 会将变量绑定在当前的块中, 不再受外部的影响, 绑定成一个死区;
    let 和 const 声明的变量不在 Global中, 是一个单独的Script区域, 在控制台中可以 debugger; 所以不能全局调用

# 函数声明的方式及区别

```JavaScript
  // 函数表达式
  var Foo = () => {
    return "函数表达式"
  }
  // 直接声明
  function Foo() {
    return "直接声明"
  }
  /**
   * 使用new实例化一个函数, 和直接声明是一样的
   */
  var Foo = new Function(
    'return "直接声明"'
  )
```

    函数表达式: 只能在声明之后调用; 运行阶段 --> 赋值给 Foo
    直接声明: 在当前的作用域下都可以进行调用; 解析阶段 --> 赋值给 Foo

# 作用域

    js中的作用域就是一套规则, 用于定义和标记变量(标识符)访问的区域;
    js中有两个作用域:
      全局作用域: 变量在整个程序中一直存在, 在任何地方都可以读取到;
      函数作用域: 变量只在函数内部存在;

# 作用域链

    js的一套查询规则, 当变量/标识符的读取时, 按照就近原则, 逐层向上, 有序的进行查询;

## 变量的查询 LHS RHS

    LHS:左侧引用
        left hand side 通配符左侧的引用(查询)<目标>
    RHS:右侧引用
        right hand side 通配符右侧的引用(查询并赋值)<源头>
      - RHS查询的时候, 和LHS调用的路径一致, 不同的是, 查询不到时, 会在全局作用域隐式声明赋值;
      - a = 1 查询不到会向windows赋值; 全局污染就是这样来的;

###### 作用域、作用域链

    作用域: 变量和函数的可访问范围; (作用域控制着: 变量和函数的可见性和生命周期)
    全局作用域: 在代码中均可以访问到
    局部作用域: 仅在固定的代码片段中可见
    块作用域: es6新增, if() for中的{}就是块作用域

    作用域链:
      1. 保证对执行环境中所有可访问变量和函数 进行有序的访问;
      2. 符合就近原则, 从最近的作用域查找起, 一直查询到全局作用域; 逐层向上查询
