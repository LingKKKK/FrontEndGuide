# 栈 堆

栈: 是一种遵循 后进先出 原则的有序集合. 类似羽毛球筒, 单口进出
栈存储的都是基本类型
执行 js 代码的地方, 提供了 js 执行的环境
内存小, 分配较快, 便于回收
堆: 随用随取, 不存在先后顺序
键值对, 代码字符串
堆存储的都是引用类型 array object

## 堆栈存在哪里?

都存在内存中, 被 GC 机制处理释放;

# 多个定时器如何存入并读取执行?

```javascript
  // 这两个函数的执行顺序是什么? 如何入栈和出栈
  setTimeout(() => {console.log(1)}, 500);
  setTimeout(() => {console.log(2)}, 300);
  // 每次调用定时器, 会生成新的栈并放入, 不在同一个栈中;

  function a(){
    setTimeout(function() {
      alert(1)
    }, 0);
    alert(2);
  }
  a();
  /**
   * alert加上定时器后, 就会生成一个新的堆栈中并存入, 并尽可能快的执行(优先级较高)
   * 执行完 a 之后, 就立即执行 alert(2), 再执行 alert(1);
   * setTimeout的作用就是脱离了当前的函数调用堆栈
   */

  给alert(1)加上setTimeout 后，alert(1)就被加入到了一个新的堆栈中等待，并“尽可能快”的执行。这个尽可能快就是指在a的堆栈完成后就立刻执行，因此实际的执行结果就是先 alert(2)，再alert(1)。在这里setTimeout实际上是让alert(1)脱离了当前函数调用堆栈。
```

# 线程 | 进程

    进程 - 是CPU资源分配的最小单位
    线程 - 是CPU调度的最小单位
    线程是建立在进程基础上的程序运行单位， 一个进程中可以有多个线程

    把进程比作火车, 线程比车厢
    1. 线程, 只能在进程下运行 (车厢无法脱离火车进行)
    2. 一个进程可以有多个线程 (火车有多个车厢)
    3. 不同进程之间的数据很难共享 (不同列车无法变通
    4. 不同的线程之间数据共享 (不同车厢可以随意走动)
    5. 进程比线程消耗更多的资源 (火车比车厢更耗资源)
    6. 进程之间不会互相印象, 但是线程会影响整个进程 (火车之间不影响, 车厢会影响整个火车)
    7. 互斥锁: 进程使用的内存可以上锁, 某些线程正在使用时, 其他线程需要等待 (火车洗手间)
    8. 信号量: 进程使用的内存可以定量 (餐车用餐数量)

# event loop

    event loop 是js的事件;
    分为两种:
      1. 宏任务 macro task: Script代码, 定时任务等
      2. 微任务 micro task: Promise.then(), Process.nextTick, MutationOberver 等
         MutationOberver: Web Api,对Dom做监听.

    ** 在JS的运行环境中,会伴随很多事件的发生: 用户点击, 页面渲染, 脚本执行, 网络请求等. 需要用到事件循环机制来对这些事件进行协调处理. 事件循环会"维护"一个或多个"任务队列"(task queue). 上面所有的事件都会存放在一个线程中. 处理一个事件之后将其移除, 这个就是一次循环. 异步代码和回调函数, 会创建一个新的队列(task), 同步的代码和微任务是顺序执行的. task执行完毕之后, 再进去下一个task执行.
    ** 同步任务和微任务就在原有的队列中顺序执行
    ** 异步任务和一些回调就会存放在一个新的队列
    ** 一条一条的执行task, 会触发一个个事件循环(执行/删除)

    事件循环:
      1. 先执行宏观任务，再执行微观任务，宏任务和微任务放置在不同的 event 队列中
      2. 同步任务进入主进程，异步进入 event 队列中，会注册函数，并将回调函数放在队列中
         「同步和异步是不同的 event 队列」
      3. 同步任务执行完毕后，从 event 队列中读取时间放在主进程中执行，回调函数可能还包含不同的任务
      4. 事件循环的过程，就是执行各种同步和异步的回调函数的过程
      * 重复上面的过程，所有的时间都会在这个循环内执行；
      * 一次循环: 执行任务, 删除任务, 继续向下执行

# 将宏任务和微任务比作银行业务

    去银行办理业务, 需要先取号(注册事件), 取完号之后排队(队列);
    排队的人, 就是一个个宏任务, 必须顺序执行;
    A开始办理业务, A所有的业务都是微任务, 可能会有很多拓展业务(Promise.then);
    A有一个朋友B也要办理业务, A不能直接办理, 需要帮B取号(异步回调);
