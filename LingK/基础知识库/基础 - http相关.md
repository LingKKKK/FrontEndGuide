# http / https

    https = http+认证+加密+完整性保护

        https的加密压缩过程、原理:
          1.服务器申请CA证书
          2.颁发证书给服务器
          3.服务端携带公钥证书分发给客户端
          4.客户端验证证书,获取公钥(对称加密)
          5.使用公钥加密报文给服务器, 携带随机串. 随机串用户传输数据时进行对称加密
          6.服务器使用私钥解密, 获取报文信息和随机串
          7.解密之后,服务器和客户端进行三次握手, 之后就可以开始传输数据

# 浏览器的缓存机制

    原理: 根据 "http报文缓存标识" 进行的
         http请求报文: request 只有post报文主体, 跟多的信息可以放在header中
         http响应报文: response
    http缓存的请求头
      1. cache-control: 请求头/响应头 | http缓存的最高指令
         no-store: 所有内容都不缓存
         no-cache: 是否使用最新的缓存
         max-age=x: 请求缓存后x秒不在请求
         s-maxage=x: 代理服务器请求缓存后x秒不在请求
         public: 客户端和代理服务器都可缓存
         private: 只有客户端可以缓存
      2. expires 响应头,资源过期时间(服务器提供)
      3. last-modified 响应头,资源最新修改时间(服务端 >> 浏览器) [3.4.做对比,计算时间]
      4. if-modified-since 请求头,资源最新修改时间(浏览器 >> 服务端) [3.4.做对比,计算时间]
      5. etag 资源标识(服务端 >> 浏览器)
      6. if-none-match 资源标识(浏览器 >> 服务端)

# 为什么使用缓存

    1. 缓解服务器压力, 并发量
    2. 节省流量, 重复性的内容较多
    3. 用户体验, 不需要每次都请求

# OIS 模型

    应用层: 操作层,和用户进行交互
    表示层: 展示文字,图片等数据
    会话层: cookie,session等
    传输层: TCP/UDP,三次握手
    网络层: 对数据进行封装,四次挥手
    数据层: 使用MAC地址进行封装
    物理层: 将数据以光电信号进行传输

# 数据传输

    	客户端                                                     服务端
    		↓                       三次握手                            ↓
    		↓    >> 建立简介, 发送 SYN 码, 客户端进入 SYN_SEND 状态 >>      ↓
    		↓  << 服务器确认之后, 返回 SYN + ACK包, 进入 SYN_RECV 状态 <<   ↓
    		↓  >> 客户端接受到服务器的syn+ack包, 向服务器发送ack确认包 >>     ↓
    		↓       此时客户端和服务器都进入 交互状态, 可数据传输             ↓
    		↓                                                         ↓
    		↓                三次握手为了确认双方的接收状态                 ↓
    		↓                                                         ↓
    		↓                       数据传输                            ↓
    		↓                                                         ↓
    		↓                  >> 客户端: 请求断开 >>                    ↓
    		↓              << 服务端: 等待业务处理完毕 <<                  ↓
    		↓                  >>  客户端: 等待中 >>                     ↓
    		↓              << 服务端: 处理完毕,可以断开 <<                 ↓
    		↓                                                         ↓
    		↓                     确保数据断开完毕                       ↓
    		↓                                                         ↓
    ## 三次握手
        客户端: 请求传输数据
        服务端: 同意数据传输
        客户端: 开始数据传输
    ## 四次挥手
        服务端: 我要断开了
        客户端: 稍等,等我处理完任务
        服务端: 好的,我等你
        客户端: 可以断开了

# http1.0

    1. 最早的协议标准
    2. 浏览器和服务器之间建立短暂连接, 每次请求创建TCP, 完成之后断开连接
    3. "请求-相应"一一对应, 效果不好

# http1.1

    1. 对http1.0做了优化, 可以持久化连接
    2. 一个TCP可以包含多个请求
    3. 优化内容:
       缓存的处理
       带宽优化, 网络连接优化
       错误通知的管理
       消息在网络中发送
       安全性和完整性

# http2.0

    1. 兼容http1.1的原有功能
    2. 充分挖掘tcp协议的能力, 更少的tcp请求
    3. 向服务器发送的request请求模型没有变化
    4. 协议写法没有变化, 和http1.1一样
    5. 可以通过代理的方式, 将http1.1升级为http2.0
    6. 不识别http2.0的话, 可以将协议降为http1.1

    [压缩头部, 二进制分帧]

# 常见的 http 状态码

    1xx: 通知
    2xx: 成功
    3xx: 重定向
    4xx: 客户端访问错误
    5xx: 服务端错误
    	200: 请求成功
    	201: 创建成功
    	300: 资源存在多个, 无法确定是哪一个
    	301: 资源URL已更新, 应使用行的URL
    	310: 域名重定向
    	400: 客户端请求格式正确, 但是请求失败
    	403: 请求资源存在, 但是服务端未处理
    	404: 请求资源不存在
    	500: 服务器响应失败
    	502: 服务器代理
    	504: 无法访问
    	505: Http版本/请求格式

# http 请求内容

    常规:
    	请求网址<Request URL>: 接口的地址
    	请求方法<Request Method>: POST/GET
    	请求状态<Status Code>: 接口的状态码
    	远程地址<Remote Address>: 121.40.43.188:443
    	来源策略<Remote Address>: origin-when-cross-origin
    请求头:
        方法<:method>: POST/GET
        接受格式<accept>: application/json, text/javascript, */*; q=0.01
        接受编码<accept-encoding>: gzip
        接受语言<accept-language>: zh-CN,zh;q=0.9,en;q=0.8
        内容类型<content-type>: application/json
        域名<origin>: https://www.baidu.com
        用户信息<user-agent>: 浏览器的版本信息等内容
    响应头:
        访问控制域名<access-control-allow-credentials>: true/false 允许访问的域名证书
        访问控制标头<access-control-allow-headers>: Accept / Token / Cookie
        访问控制方法<access-control-allow-methods>: POST / GET / CREATE / DELETE
        访问控制域名<access-control-allow-origin>: https://blog.csdn.net
        设置Cookie值<set-cookie>: 设置一些cookie值
        访问时间<Date>: JS的Date()日期
        响应编码<content-encoding>: gzip
        响应类型<content-type>: text/html
        缓存内容<Cache-Control>: 浏览器缓存

# https 的缓存机制

    浏览器和服务器之间的联系是应答模式, 即: 浏览器发送http请求 -> 服务器进行响应.
    浏览器在第一次请求拿到结果后, 会根据http缓存标识(Cache-Control)决定是否缓存结果(将结果和缓存标识写入浏览器).

    	** 首次请求资源
        浏览器                                  浏览器缓存                      服务器
          ↓       >>>> 第一次发送http请求 >>>>        ↓                           ↓
          ↓     << 没有该请求的缓存标识和缓存结果 <<     ↓                           ↓
          ↓                 >> 没有缓存标识和结果就向服务器发送http请求 >>            ↓
          ↓                  <<<< 缓存该http请求的结果, 和缓存的请求 <<<<           ↓
          ↓    >> 将该请求的结果和缓存标识存入浏览器 >>   ↓                           ↓
        浏览器                                  浏览器缓存                      服务器

    浏览器访问时:
      1.浏览器每次发送http请求时,都会在浏览器缓存中查找该请求的记过及缓存标识
      2.浏览器每次拿到返回结果时,都会将该结果和缓存标识存入浏览器
      * 确保每个请求的缓存存入与读取
      * 根据是否需要向服务器重新请求缓存内容, 将缓存分为: 强制缓存 / 协商缓存

## 强制缓存

    强制缓存是: 向浏览器缓存查找该请求的结果, 并根据该结果的缓存规则, 来决定是否使用该缓存的过程.
    1. 不存在该缓存结果和缓存标识, 强制缓存失效, 需要重新发送请求
    	 最后一次是: 无缓存标识, 发送http请求
    2. 存在该缓存的结果和缓存标识, 但是已经失效, 则使用协商缓存(暂不分析)
    	 最后一次是: 携带缓存标识, 发送http请求
    3. 存在该缓存的结果和缓存标识, 且未失效, 强制缓存生效并使用
    	 浏览器缓存返回强制读取缓存内容, 不再向http发送资源请求
    ** 强制缓存的规则:
    	 当浏览器向服务端发送请求时, 服务器会将缓存规则放入http响应的报文的 http头 中, 和请求一次返回给浏览器.
    	 控制强制缓存的字段分别是: Cache-Control 和 Expires; (Cache-Control优先级更高)
    	 Cache-Control和Expires都有很多子项,通过子项控制缓存的配置.

## 协商缓存

    协商缓存: 在强制缓存失效之后, 携带标识发起请求, 由服务器根据缓存标识判断是否使用缓存的过程.
    1. 协商缓存生效, 返回304 (资源无更新)
     浏览器                                  浏览器缓存                      服务器
       ↓       >>>> 第一次发送http请求 >>>>        ↓                           ↓
       ↓     << 该缓存的结果失效, 只返回标识 <<      ↓                           ↓
       ↓                        >> 携带缓存标识向服务器发送http请求 >>           ↓
       ↓                           <<<< 304 该资源无更新 <<<<                 ↓
       ↓      >>>> 获取 该请求的缓存结果 >>>>       ↓                           ↓
       ↓      <<<< 返回 该请求的缓存结果 <<<<       ↓                           ↓
     浏览器                                  浏览器缓存                      服务器

    2. 协商缓存失效, 返回 200 (资源更新)
       浏览器 浏览器缓存 服务器
       ↓ >>>> 第一次发送 http 请求 >>>> ↓ ↓
       ↓ << 该缓存的结果失效, 只返回标识 << ↓ ↓
       ↓ >> 携带缓存标识向服务器发送 http 请求 >> ↓
       ↓ <<<< 200 该资源已经更新 <<<< ↓
       ↓ >>>> 将缓存和缓存标识存入缓存中 >>>> ↓ ↓
       浏览器 浏览器缓存 服务器
       \*\* 协商缓存的字段: last-modified / if-modified / etag 等

### 浏览器的缓存在哪里? 如何判断强制缓存是否生效?

    可以查看network中的size
    	有大小值(8kb)就是没有使用缓存, 有 from memory cache / disk cache 就是调用了强制缓存
    	from memory cache: 内存中的缓存
    	disk cache: 硬盘中的缓存
    	优先级: 内存中的缓存 > 硬盘中的缓存
    	首次请求页面 >>> 200(已经存入memory/disk) >>> 关闭页面 >>> 重新打开页面 >>> disk >>> 刷新页面 >>> memory
    eg.
    	js/图片等解析式的文件, 存入memory cache中(刷新页面读取内存).
    	css等静态资源存在disk cache中(每次渲染都从硬盘读取).
