# 浏览器的工作流程
    渲染引擎的工作流程:
      1. 解析html, 构建 dom树
      2. 构建 render树(css)
      3. 布局 render树
      4. 渲染 render树
    解析的过程:
      1. html解析: 根据标签构建树, 有容错机制
      2. css解析: 匹配选择器, 从右到左依次解析
      3. js解析: 预加载 逐行解析
      * js css 的顺序影响解析的顺序

# 回流/重绘
    回流 reflow -> 影响布局, 需要回过去重新进行渲染
    重绘 repaint -> 不影响布局, 仅修改部分样式
    *** 回流一定会触发重绘, 但重绘不一定触发回流
    如何优化:
      1. 尽量避免大量的dom操作
      2. 尽量减少浏览器尺寸变更的操作
      3. react/vue中的虚拟dom和diff算法
      4. 批量操作, 集中处理, react调和过程
      5. css3新特性中 opacity transform filter 不会触发回流重绘(牺牲硬件, 提升性能)

# V8 渲染引擎
    - 一般来说, 编译性语言的运行效率要高于解释性语言; 部分解释性语言通过运行时的动态编译, 性能超过编译性语言;
    编译性语言的跨平台特性比解释性更差一点;
    - js是解释性语言, 运行效率低, 随着web的发展, js承担越来越多的工作; 需要更快速的解析js脚本; V8引擎就是为了解决这个问题而产生的; node中也是采用v8引擎来解析js;
    - 渲染引擎: 将html/css/js 将对应的资源文件转换成图像, 让用户可见

# 从输入 url 到页面渲染完毕
    地址栏输入url
    浏览器内核加载相应的资源
    建立数据通信模型
    同步/异步处理请求
    调用html解析器
    构建dom树
    调用js/css/视频等解析器进行构建
    调用绘图, 绘制上下文
    对图像处理, 最终呈现

[https://blog.csdn.net/qq_30638831/article/details/90552912]

# 各浏览器的私有前缀
  谷歌/Safair: -webkit-
  火狐       : -moz-
  IE        : -ms

# 浏览器缓存
  浏览器缓存(http缓存)
