# 微前端的实现和对比

## 实现的方式

**iframe**
在页面中某一个容器引入展示
通过 postMessage 的方式进行页面之间的通信
_优势_

- 技术成熟
- 支持页面嵌入
- 天然支持`运行沙箱隔离`,`独立运行`
  _劣势_
- 页面之间是可以不同域名
- 需要设计应用通信机制,如何监听传参等内容
  - postMessage 传递参数较为随意,需要进行严格约束
- 应用的加载、渲染、缓存依靠浏览器实现,不能控制

**Web Component**
H5 中技术,组装定义自己的组件
_优势_

- 支持自定义元素
- 支持 shadow dom,通过关联关系进行控制
- 支持 templete 和 slot 功能,可引入自定义组件
  _劣势_
- 子应用接入微前端,需要重写项目
- 生态不完善,对浏览器的兼容性不够好
- 整体架构设计复杂,组件之间解耦的同时,会造成通信复杂度的提升和控制器逻辑的繁琐
  - 控制手段复杂

**自研框架**
_优势_

- 高度定制化,满足需要做兼容的一切场景
  - 对浏览器的版本针对性的升级即可
- 独立的通信机制和沙箱运行环境,可解决应用之间的相互影响问题
- 支持不同技术栈应用,可做到页面的无刷新渲染
  _劣势_
- 技术实现难度较高
- 需要设计一套通信机制(通信体系)
- 首次加载微前端可能出现资源加载过大的情况(需要深入优化)

## 自研微前端框架

- 路由分发式,来处理子应用的渲染
- 主应用控制路由和子应用的加载,共享依赖内容,提供方法供子应用调用
- 子应用做功能上的渲染,接入主应用的`控制`和`联动`规范

# Tips

## 微前端的内核

- 主应用框架的`加载`,`渲染`,`通信`,`路由`
- 子应用的`JS运行环境`,`沙箱`
- 对子应用进行改造 (最好使用工程化的工具自动完成)
- 主应用初始化时提供所需子应用的信息,通过配置管理平台来操作
- 常规的脚手架和发布工具等

## 期望达到的路由效果

- 主应用集成了子应用之后,通过一个具体的路径访问主应用,以及能调度到子应用的路由. (主子应用的路由完全独立且分离)
- 子应用的路由切换之后,主应用的路由也随之变化.
- 浏览器的前进后退功能正常使用

[主应用和子应用的路由组合](https://blog.csdn.net/weixin_43825389/article/details/109313017)

## 主应用是 hash 模式

主应用是 hash 模式的时候,子应用一般也都是 hash 模式,主应用会分配一个`/#/base1`
此时子应用如果需要在`/#/base1`路径上进行 hash 模式的二级路径跳转`/#/base1/child1`,子应用需要手动添加`base1`的前缀.
VueRouter 的 hash 模式下,不支持 base 参数添加,需要手动执行一下. ??? 不确定

**主应用 hash 模式,子应用 history 模式,会出现各种跳转 bug,不做深入探讨了**

_主应用 hash_
在路由中正常配置,添加一下`base`,在不同版本的 VueRouter 调用的 API 可能不太一样,为了声明一下主应用的路由激活入口
在`main.js`中,调用`qiankun`的 api,通过`activeRule`配置激活对应的子应用,被激活的路由需要添加`#/`前缀; (可以思考一下路由的形式)
例如,我在这里添加一个 vue 的子应用,激活路由为`#/vue`
_子应用 hash_
在每个路由中,都要添加被激活的路由`#/vue`; 这个前缀和主应用中配置该子应用的激活前缀相匹配;
因为子应用是 history 模式,不需要添加`#`,这个`#`是主应用中需要的.

## 主应用是 history 模式

当主应用使用`history`模式,子应用使用`hash`模式,表现比较好,如果子应用需要添加`base`路径,设置对应属性即可.
_主应用 history_
在路由中正常配置
在`main.js`中,不需要添加`/#/`,使用`history`对应的配置即可.注意`VueRouter`不同版本的声明方式*多看文档*
_子应用 hash_
子应用的路由配置中,正常配置,添加一下`base`属性,这个属性和主应用中的激活属性要保持一致.
在每一个路由地址中,都添加对应的`base`,确保能访问到对应的路由
_子应用 history_
表现完美,如果有条件推荐使用
如果路由中,不添加`base`属性,需要手动配置`url`,添加对应的激活属性, 如果添加了`base`,不需要做任何修改.

## 注意

[应用的路由关系](https://blog.csdn.net/alitech2017/article/details/106901454/)
**主应用和子应用共享路由**
主应用根据路由来调度(激活)子应用,子应用内部的状态变化反映在路由上(路由变更会映射到主应用上);

- 不同的子应用如果存在相同的路由,就会产生冲突「路由抢占 | 共享资源抢占」;
  - 首先,主应用通过特定的字符串激活路由,如果配置相同的话,就会产生冲突
  - 其次,在子应用中路由表也不允许存在相同的路由
  - 规避:对共享资源切片处理
    - 切片：将资源分离成多个独立空间，和每个子应用一一对应，这样就可以实现资源的完全隔离
    - 通过特定的前缀约定等方式，这个约定就是子应用激活的开关，当触发这个开关的时候才会激活进入到子应用中
    - 特定前缀（激活开关）
      - 在主应用中定义，在切换的时候，路由前追加该前缀
      - 在子应用的路由中将其作为前缀、router-base 属性
- 初次进入主应用是初始状态,激活路由需要手动配置

## JavaScript 沙箱

[沙箱隔离子应用](https://blog.csdn.net/alitech2017/article/details/106901454/)
[阿里云开放平台微前端方案的沙箱实现](https://www.h5w3.com/145132.html)
[前端沙箱隔离及配置](https://blog.csdn.net/qq_44746132/article/details/117385571)
隔离的核心：不同子应用对全局资源的访问要受限
而在浏览器的语境下，这意味着两点： 1.隔离对全局上下文产生的副作用； 2.完全隔离 DOM、BOM

_隔离全局变量的核心解决方法就是_

- 将全局变量降为局部变量，常规的方法就是将子应用闭包化；
- 在激活子应用的时候，传入全局变量的副本即可，使用完毕即销毁。

### css 样式隔离

#### 问题一:CSS 样式冲突问题

前提：在主应用（view）中，使用的 UI 库是 elementUI，子应用（syncDisk）使用的 UI 库是 AntDesign。
问题：在子应用中，点击按钮弹出弹窗，最外层的遮罩 div 无法实现渐入渐出的效果。
分析：elementUI 和 AntDesign 都使用了`fade-enter-active`这个 className，但是`fade-enter-active`所表示的意义不同，在 AntDesign 中，它的作用是执行`animation`动画;在 elementUI 中，它的作用也是渐入动画，但是需要配合`fade-enter-to`使用，已达到渐入渐出效果。下面是两个框架的 css 代码片段。
解决：

1. 使用 css 沙箱隔离
   不可行。
   因为 css 沙箱隔离会将所有的 css 都隔离在 shadowDom 中，`问题一`涉及到的全局遮罩就无法满足，因为 css 隔离定义，不太方面。从定义出发，`qiankun`的沙箱初衷为了隔离`子应用`之间的覆盖问题，但是从使用上来说，已经影响到了主应用和子应用之间的关系，涉及到样式外穿就无法满足。
2. namespace ✔️
   给组件或者 class 添加前缀，修改源码中的 class 类型，重新定义
   filez-design 可以定义`filez`开头的 class，这样就避免样式重叠
3. 自定义弹窗遮罩 ✔️
   使用弹窗的时候，屏蔽掉默认的遮罩，使用自定义的遮罩层。换言之，涉及到全局样式的内容都需要单独处理。

```css AntDesign
.fade-enter.fade-enter-active {
  animation-name: antFadeIn;
  animation-play-state: running;
}
@-webkit-keyframes antFadeIn {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
```

```css ElementUI
.fade-enter-active {
  transition: all 0.4s;
}
.fade-enter-to {
  opacity: 1;
}
.fade-enter {
  opacity: 0;
}
```

#### 问题二:应用路由模式的选择

[参考](https://juejin.cn/post/6856569463950639117#heading-23)
一、主应用 hash 模式,子应用没有 history 模式
**用 path 区分子应用**
_优点_
不需要修改子应用代码
_缺点_
应用之间的跳转,需要借助`原生的histroy对象`
**用 hash 区分子应用** => 利用`activeRule`属性进行激活
_优点_
页面的跳转使用应用自己的路由,不需要借助主应用路由对象和原生 history 对象来实现
_缺点_
对子应用是入侵式的修改,极不建议在旧应用中使用,影响范围太大

二、主应用 hash 模式,子应用有 history 模式
**子应用间的跳转只能借助原生的 histroy 对象实现**
用 path 区分子应用,优劣和上述类似
用 hash 区分子应用,没有任何优势,纯粹的破坏子应用

三、主应用 history 模式
_优点_ 1.子项目可以选择任意模式,接入成本较低,兼容性比较强 2.对 hash 模式的子应用没有任何影响,不需要做任何修改
_缺点_
1.history 模式路由需要设置 base 2.子应用之间的跳转依赖主应用的 route 对象(不建议使用 a 标签,因为 a 标签会刷新页面)

- 使用`原生的histroy对象`也可以实现跳转,参考做的第一个微前端 dom

#### 应用之间的组件共享

不涉及,暂时不考虑

#### 基于 qiankun 改造的事件机制、通信机制

## 应用之间的通信

[参考](http://www.icodebang.com/article/302829)

# qiankun 框架的改造

## 路由改造

尝试对 qiankun 框架中的路由进行二次改造,最后发现改造的意义并不大.
**问题**: 改造路由最终的目的是做拦截, 想一下为什么要做拦截?
做一个拦截器无非是实现以下几种操作:
1.对请求做处理
2.对请求异常做处理
3.对响应做处理
3.对响应异常做处理

## 应用通信
[参考](https://www.freesion.com/article/1714630234/)

对于应用之间的通信,qiankun封装了一套自己的通信机制,有点像观察者模式.
1.qiankun提供全局状态池 globalState
2.qiankun提供了一个观察者池,每个子应用注册的时候会注册一个观察者onGlobalStateChange
3.将这个观察者压入观察者池中
4.每当应用调用setGlobalState修改state,会修改全局状态池globalState,同时通知观察者触发观察池
5.当应用销毁的时候,将对应的观察者从观察池中移除(每个应用有且只有一个观察者,从内存的性能考虑)

### action通信 和 shared通信
action通信就是MicroAppStateActions.
action通信是通过全局状态池和观察者函数进行应用间的通信.适用于绝大多数场景.
 - 优点
  - 使用简单
  - 支持度高
  - 适用于通信较少的业务场景
 - 缺点
  - 子应用独立运行时,需要配置action的容错逻辑
  - 子应用需要连接状态池细节,再进行通信
  - 状态池无法被跟踪,通信场景较多时,状态混乱,维护困难

如果应用通信的逻辑比较复杂,希望子应用具备独立完成的能力时,考虑使用Shared通信方式.

## MicroAppState vs PostMessage
microAppState是qiankun提供的action通信模式.
PostMessage是基于html5协议的.

从实现来说,属于两种完全不同的模式.
action模式是利用了观察者模式,将子应用注册观察者并放入观察池,当数据变化时通知到所有的子应用.监听基座中的数据.
MessageChannel/postMessage就是单纯的两个origin的通信,可以传输任意可序列化的内容.

**没有什么可比性,面向的场景不同.**
