# class 组件和 hooks 的对比关系

**函数组件是没有声明周期的,只有一个 render 函数用来返回内容**

constructor >>> useState
getDerivedStateFromProps >>> useState 中的`update`
shouldComponentUpdate >>> useMemo
render >>> 函数本身(函数的 render 是必须项)
componentDidMount >>> useEffect
componentDidUpdate >>> useEffect
componentWillUnmount >>> useEffect 中`返回的函数`
componentDidCatch >>> 无
getDerivedStateFromError >>> 无

# 声明周期

## v16.3 之前

可以将声明周期划分为三个阶段: 挂载阶段/组件更新阶段/卸载阶段

- 挂载阶段:
  - componentWillMount
  - render
  - componentDidMount
- 组件更新阶段:
  - props
    - componentWillReceiveProps
    - shouldComponentUpdate
    - componentWillUpdate
    - render
    - componentDidUpdate
  - state
    - shouldComponentUpdate
    - componentWillUpdate
    - render
    - componentDidUpdate
- 卸载阶段
  - componentWillUnmount

**存在的问题**
当更新复杂数组最上层的组件时,调用栈会比较长. 因为生命周期的钩子要逐层触发.
当足够复杂时,存在长时间阻塞进程的可能,可能带来不好的用户体验. `Fiber`就是为了解决这个问题而产生的

## v16.3 之后

`Fiber`本质上是一个虚拟的堆栈帧,新的调度器会按照优先级,自由调度这些帧;
从而将之前的同步渲染修改为异步渲染,在不影响体验的前提下分段计算更新.

对于异步渲染分为两个阶段

1. state getDerivedStateFromProps
   该函数在挂载阶段和组件更新阶段都会执行(即:每次获取新的 props 和 state 之后都会被执行).在挂载阶段用来替代`componentWillMount`,在组件更新阶段配合`shouldComponentUpdate`.可以覆盖`componentWillReceiveProps`的所有用法.
   它是一个静态的函数,函数体内无法访问 this,会根据`nextProps`和`prevState`计算出超出预期的状态改变.并将结果返回给`setState`,返回`null`则说明不需要更新`state`,这个返回内容是必须的
2. getSnapshotBeforeUpdate
   该函数在`render`之后,在`DOM更新`之前被调用,用于读取最新的`DOM数据`.
   返回一个值,作为`componentDidUpdate的第三个参数`;配合`componentDidUpdate`,可以覆盖`componentWillUpdate`的所有用法.

- 挂载阶段
  - constructor
  - getDerivedStateFromProps
  - render
  - **React 更新 DOM 和 Refs**
  - componentDidMount
- 组件更新阶段
  - new Props / setState() / forceUpdate()
  - getDerivedStateFromProps
  - shouldComponentUpdate
  - render
  - getSnapshotBeforeUpdate
  - **React 更新 DOM 和 Refs**
  - componentDidUpdate
- 卸载阶段
- componentWillUnmount

_误区_

1. `getDerviedStateFromProps`和`componentWillReceiveProps`只会在`props`改变时才会调用?
   只要父级重新渲染,`getDerviedStateFromProps`和`componentWillReceiveProps`都会重新调用,不管`props`是否发生变化. 所以这两个方法将`props`赋值到`state`是不安全的. 因为不止有`props`
   [参考案例](https://blog.csdn.net/lunahaijiao/article/details/99434993)
   解决方式: 完全可控组件/完全由 props 控制不派生 state/
2. 应避免直接将`props`赋值给`state`
   这样一来,数据源会比较乱,逻辑很难维护;
   state仅为自身变量, props为接收到的变量

# 多组件之间,声明周期的执行顺序

## 父子组件 (更新阶段)

- 父组件 getDerivedStateFromProps
- 父组件 shouldComponentUpdate
- 子组件 getDerivedStateFromProps
- 子组件 shouldComponentUpdate
- 子组件 getSnapshotBeforeUpdate
- 父组件 getSnapshotBeforeUpdate
- 子组件 componentDidUpdate
- 父组件 componentDidUpdate

## 父子组件 (卸载阶段)

父组件先执行`componentWillUnmount`
子组件总按照JSX中的定义顺序依次执行各自方法

# 高阶组件的生命周期
