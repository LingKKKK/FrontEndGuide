# React 调度算法

[ˈskɛdʒʊlər]

## React-scheduler

### 为什么需要调度?

`vue`和`react`的`核心机制`不同;
`vue`的核心原理是`数据劫持`加`发布订阅`,并且收集这些`依赖的更新`,到组件级别的更新.
`react`并没有进行数据劫持/数据绑定.每次更新都是从`根节点`开始,逐层向下进行`diff`,比较耗时耗性能.这也意味着将会阻塞浏览器的渲染进程.变现的结果就是:更新一次页面可能出现短暂白屏的情况.
如果能够分摊出一些内存来执行 js 的计算操作,在浏览器渲染的时候,暂停 js 的 diff 对比,在渲染完毕后,再执行 diff 算法对比...依次将所有的 diff 和渲染工作执行完毕,那么就解决了性能损耗的问题了.

### 如何实现异步调度?

- 了解浏览器的空闲时间
- 异步触发更新任务
- *requestIdleCallback*是浏览器保留的api,当空闲时,执行里面的回调
  - `requestIdleCallback( callback, { timeout } )`
- 需要先了解一下`帧`和`流畅度`的概念

### FPS 和 页面流畅度

页面都是一帧一帧的绘制的,每秒绘制的帧数为 60(fps)的时候,页面相对比较流程,小于这个数值就比较卡顿.
分配给每帧的时间 `1000 / 60 = 16ms`,所以代码的渲染尽量保证一帧不超过`16ms`;
_每一帧浏览器需要完成的工作_

- 处理用户的交互
- JS 解析执行
- 帧开始: 窗口尺寸变更,页面滚动等
- requestAnimationFrame
- 布局
- 绘制

_在每一帧完成上述 6 个内容之后,空余的时间就是`react`执行`requestIdleCallback`注册的`调度任务`_

### 浏览器渲染

利用事件循环中的 _宏任务_ 可以做到: 即不阻塞界面渲染,并且能执行一个任务之后继续执行下一个任务;
利用浏览器多进程的特性.

- Brower 进程
- 第三方插件进程
- GPU 进程
- 渲染进程 ☆☆☆
  - 事件
    - 页面渲染
    - js 的运行
    - event loop
  - 包含的线程
    - GUI 线程 [互斥] (密级的 js 会将 GUI 阻断,表现为卡顿)
    - JS 引擎线程 [互斥]
    - 事件线程 (当 JS 引擎执行代码的时候,将异步代码放在这里,批量释放给 JS 引擎执行<Event Loop>)
    - 定时器线程
    - http 请求线程

宏任务:
每次`执行栈`的代码,都是一个宏任务.
每一个`task`会`从头到尾`的执行,不会执行其他的代码.
浏览器为了能够使`js内部task`与`DOM任务`能够有序的执行,会在`task`执行结束后,下一个 task 执行之前,对页面渲染.
**这刚好是 React 异步渲染所需要的, 刚好满足 React 的需求**
常见的宏任务有: setTimeout setInterval MessageChannel
tips: 1. MessageChannel 的优先级最高, `定时器`会浪费 4ms 的时间 2. 执行栈: 调度栈/控制栈/运行时栈;需要执行的代码,都会被压入执行栈;
微任务:
当`task`结束之后,`微任务`会被立即执行.
当`task`执行完毕之后,下一个`task`执行之前,他不需要等待渲染,高优先级执行.
常见的微任务有: 先于 Promise.then process.nextTick(node 环境中的最高优先级)

**思路**
react 采用`MessageChannel`去实现`requestIdleCallback`注册任务回调.

### 异步调度的具体流程

ensureRootIsScheduled

- react 发生更新时,都会进行这个调度入口
- 正常的更新,会走`performSyncWorkOnRoot`逻辑, 最后会走`workLoopSync`
- 对于低优先级的异步更新,会走`performConcurrentWorkOnRoot`逻辑,最后走`workLoopConcurrent`
- 再一次更新调度的过程中,`workLoop`会更新每一个待更新的`fiber`.
- 异步模式会调用`shouldYield方法`,当浏览器没有空闲的时候,异步的`shouldYield方法`会终止操作
  tips: `fiber`就是虚拟调用堆栈,专门用于处理任务

scheduleCallback

- `scheduleCallback`是一个调度器, 其作用是:调用`workLoopSync`和`workLoopConcurrent`
  - 这两个异步队列的区别是: 低优先级异步任务的处理比同步多了等待的概念, 同步顺序执行,不需要考虑等待
- React 将优先级从高到低划分:
  - `NoPriority`: 初始化、重置 root、占位用
  - `ImmediatePriority`: 立即同步执行, 且不能中断,用来执行过期任务
  - `UserBlockingPriority`: 会阻塞渲染的优先级,用户交互的结果, 需要及时得到反馈
  - `NormalPriority`: 默认和普通的优先级,比如网络请求
  - `IdlePriority`: 空闲优先级,用户不在意、一些没必要的任务
- 具体的工作流程:
  - 进入到`schedule`的`unstable_scheduleCallback`中
  - 执行`Schedule.scheduleCallback`生成`tack`任务
  - 根据是否传递`delay`参数,结合`startTime`和`endTime`,将`task`放到`timerQueue`或者`taskQueue`
    - 当`startTime`大于`endTime`,会进入`timerQueue`
      - 通过`requestHostTimeout`执行`handleTimeout`
    - 当`startTime`小于`endTime`,会进入`taskQueue`
      - 通过`requestHostCallback`进行调度

requestHostCallback
它的作用就是: 执行 React 的调度任务
在不同的平台下,实现的方式不同.
将`flushWork`放到`MessageChannel`的回调函数中

flushWork
如果有延时任务,会将其暂停掉,优先执行`workLoop`,然后再去执行`超时的更新任务`
给任务排序,按照优先级执行

workLoop
它的作用是: 更新`taskQueue`任务.

```
  scheduleCallback >>> 派发task >>> timerQueue (延时执行)
                                        ↓
                                        ↓ 将task延后执行
                                        ↓ requestHostTimeout >>> handleTimeout
                                        ↓
  scheduleCallback >>> 派发task >>> taskQueue (优先执行)
                                     ↓   ↑
                 requestHostCallback ↓   ↑ 循环消费taskQueue
                       向浏览器请求一帧 ↓   ↑ 直到把所有的task都执行完毕
                                     ↓   ↑
                                    workLoop

```

MessageChannel

- React 会调用`requestHostCallback`,将`flushWork`赋值给`scheduleHostCallback`
- `port2`向`port1`发起`postMessage`消息通知
- `port1`接收到消息,会立即执行`scheduleHostCallback`,也就是`flushWork`对应的更新任务
- 执行完毕之后,清空`scheduleHostCallback`
  _tips: 这样就完成了整个异步调用的效果_

### timerQueue taskQueue 的数据结构

- 根据任务的优先级进行排序,React采用`小顶堆`的数据结构;
- 每次`插入堆`的时间复杂度为`log2n`.
- 堆是可以用数组表示的数据结构.
- 小顶堆保证父节点比子节点小 (在数组中排序更靠前)


### 时间分片

React让浏览器来控制React的更新
  - 浏览器每执行一次事件循环
    - 处理事件
    - 执行js
    - 调用requestAnimation
    - 布局Layout
    - 绘制Paint
    - *空闲时间* 执行`requestIdleCallback`的回调
      - `requestIdleCallback(callback,{ timeout })`
      - callback: 想要执行的回调函数
      - timeout: 超时事件;
        - 为了防止执行时间过长,导致浏览器卡死,设定了5个优先级
        - `Immediate`: -1 需要立刻执行。
        - `UserBlocking`: 250ms 超时时间250ms，一般指的是用户交互。
        - `Normal`: 5000ms 超时时间5s，不需要直观立即变化的任务，比如网络请求。
        - `Low`: 10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。
        - `Idle`: 一些没有必要的任务，可能不会执行。
