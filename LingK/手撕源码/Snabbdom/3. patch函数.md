
# patch函数是渲染的核心

patch函数执行的过程, 就是将解析VNode渲染成DOM的过程

参数: patch(oldVnode,newVnode)
功能: 打补丁,将新节点中变化的内容渲染到真实的DOM,最后返回新节点,作为下一次对比的旧节点.

过程:
  1. 对比新旧节点的`VNode`是否为相同节点
     `key`值和`sel`选择器,都是唯一的属性,可以横向对比.
  2. 如果不是相同节点, 删除之前的内容, 重新渲染新的内容
  3. 如果是相同的节点, 判断`新的VNode`是否有`text`
  4. 如果存在`text`并且新旧`text`不同,直接替换文本内容; 否则不做任何变动
  5. 如果新的`VNode`存在`children`,判断子节点是否有变化,判断同层级的节点的过程调用前面的逻辑

  * 整个对比的过程就是diff算法.


# 源码简析

```js # src/snabbdom.ts
  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    // 保存新插入节点的队列，为了触发钩子函数
    const insertedVnodeQueue: VNodeQueue = [];
    // 执行模块的 pre 钩子函数
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
    // 如果 oldVnode 不是 VNode，创建 VNode 并设置 elm
    if (!isVnode(oldVnode)) {
      // 把 DOM 元素转换成空的 VNode
      oldVnode = emptyNodeAt(oldVnode);
    }
    // 如果新旧节点是相同节点(key 和 sel 相同)
    if (sameVnode(oldVnode, vnode)) {
      // 找节点的差异并更新 DOM
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      // 如果新旧节点不同，vnode 创建对应的 DOM
      // 获取当前的 DOM 元素
      elm = oldVnode.elm as Node;
      parent = api.parentNode(elm);
      // 触发 init/create 钩子函数,创建 DOM
      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        // 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中
        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));
        // 移除老节点
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }
    // 执行用户设置的 insert 钩子函数
    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);
    }
    // 执行模块的 post 钩子函数
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    // 返回 vnode
    return vnode;
  };
```
