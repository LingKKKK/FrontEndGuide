
## 生命周期
- 每个Vue实例在被创建时, 都会尽力init初始化的过程;
- 在这个过程会执行一些操作: 绑定data, 设置Watcher监听data, 编译template, 插入DOM, 添加hooks;
- hooks: 生命周期钩子函数, 在特定的场景下会触发函数;

源码中最终执行生命周期的函数都是调用 callHook 方法，它的定义在 src/core/instance/lifecycle 中：
```js
    export function callHook (vm: Component, hook: string) {
      /**
       * 调用钩子函数时, 禁止使用dep收集
       * 过程:
       * 1. 传入hook的字符串名, 然后拿到回调函数数组(vm.$options)
       * 2. 将vm作为上下文, 遍历hook数组执行
       * *  需要了解到每个钩子的调用时机
       */
      pushTarget()
      const handlers = vm.$options[hook]
      if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
          try {
            handlers[i].call(vm)
          } catch (e) {
            handleError(e, vm, `${hook} hook`)
          }
        }
      }
      if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook)
      }
      popTarget() // 得到一个订阅者
    }
```
```
|—————————Vue实例初始化阶段———————————————————————
|                       new Vue
|                             * 启动Vue执行环境, 创建Vue实例
|             开始初始化  ◀️   ⬇️
|                         init: event & lifecycle (事件 & 生命周期)
|                             * 初始化事件环境
|         beforeCreate  ◀️   ⬇️   ▶️  this √ $option √ $el × $data ×
|                         init: injection & reactivity (注入 & 响应式)
|                             * 初始化Vue的基本功能: 绑定
|              Created  ◀️   ⬇️   ▶️  this √ $option √ $el × $data √
|———————————————————————————————————————————————
                            ⬇️
|—————————容器初始化阶段———————————————————————————
|                         判断是否有el选项: 如果没有el选项, 就等待el动态绑定: vm.$mount(el);
|                           ⬇️
|                         Has “template” option: 确定是否自定义页面的模板结构
|                             * Compile template into render function
|                               以定义的template的html结构作为模板编译
|                             * Compile el’s outerHTML astemplate
|                               以定义vue时指定的el对应的html作为模板编译
|                           ⬇️
|                         输出 render function: vNode -> vDom
|  完成了构建工作,准备挂载  ◀️   ⬇️
|                           ⬇️
|          beforeMount  ◀️   ⬇️   ▶️  this √ $option √ $el √ $data √
|                         Create vm.$el and replace "el" with it
|                             * 构建vDom完毕, 完成实例和虚拟Dom的关联
|                             * 将关联的容器替换到页面的el位置; 完成之后挂载才完毕;
|              Mounted  ◀️   ⬇️
|                         Mounted: 此时完成了挂载,
|———————————————————————————————————————————————
                            ⬇️
|—————————用户操作阶段: Vue维护一个Data ————————————
|                         Data
|                           ⬇️
|                         when data changes
|                             * 等待用户对数据进行操作
|         BeforeUpdate  ◀️   ⬇️
|                         Virtual Dom re-render and patch
|                             * Dom重新patch并替换完毕
|                             * vm.$nextTick(): 将函数放在这个节点中, 等待页面Dom更新完毕执行
|              Updated  ◀️   ⬇️
|                         Data
|———————————————————————————————————————————————
         vm.$destroy()  ◀️   ⬇️
|—————————Vue组件销毁的阶段————————————————————————
|                           ⬇️
|        BeforeDestroy  ◀️   ⬇️
|                           ⬇️
|                         TearDown watcher,child component and event listener;
|                             * 解除数据绑定, 删除子组件, 移除事件监听
|                           ⬇️
|            Destroyed  ◀️  Destroyed
|———————————————————————————————————————————————
```
[参考](https://blog.csdn.net/qq_45398848/article/details/100998008)

### 没有el选项时, 如果继续运行 ???
判断获取到el选项之后,才能正常的挂载; 必须要存在el,如果没有el的话,等待动态绑定el;
```js
    const vm = new Vue({
      // el:"#root",
      data:{
          str:"数据内容"
      }
    });
    // vm.$mount("#root");
    btns.onclick = function () {
      vm.$mount("#root");  //绑定元素
    }
```

### 组件嵌套时, 钩子函数是如何运行的?
思考一下koa的洋葱模型
```shell
# 加载渲染过程:
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
# 子组件更新过程:
父beforeUpdate->子beforeUpdate->子updated->父updated
# 父组件更新过程:
父beforeUpdate->父updated
# 销毁过程:
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

* 流程都是同步的任务
```

### keep-alive的钩子函数是如何运行的?
activated：页面第一次进入的时候，钩子触发的顺序是created->mounted->activated
deactivated ：页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated
减少了初始化解析挂载的过程;
在router中配置router.meta,keep-alive等属性

### beforeCreate & created
在实例化Vue的阶段进行触发
`src/core/instance/init.js`
```js
  Vue.prototype._init = function (options?: Object) {
    /**
     * @initState 初始化props,data,methods,watch,computed等内容
     * @beforeCreate 在initState之前, 所以上面的内容都无法调用
     * 仅进行了实例化, 还没有渲染DOM(渲染在patch阶段完成), 所以无法访问到DOM;
     * vue-router和vuex都混合了beforeCreate钩子
     */
    // ...
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')
    // ...
  }
```

### beforeMount & mounted
在挂载DOM阶段触发, 在`mountComponent`函数中执行
`src/core/instance/lifecycle.js`
```js
    export function mountComponent (
      vm: Component,
      el: ?Element,
      hydrating?: boolean
    ): Component {
      vm.$el = el // 构建的vDom, 将其绑定在 vm.$el上
      // ...
      callHook(vm, 'beforeMount')
      /**
       * 在执行vm._render渲染之前, 先调用了@beforeMount
       * 在执行vm._update将vNode patch到真实的DOM之后, 调用了@mounted
       */
      let updateComponent
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        updateComponent = () => {
          const name = vm._name
          const id = vm._uid
          const startTag = `vue-perf-start:${id}`
          const endTag = `vue-perf-end:${id}`

          mark(startTag)
          const vnode = vm._render()
          mark(endTag)
          measure(`vue ${name} render`, startTag, endTag)

          mark(startTag)
          vm._update(vnode, hydrating)
          mark(endTag)
          measure(`vue ${name} patch`, startTag, endTag)
        }
      } else {
        updateComponent = () => {
          vm._update(vm._render(), hydrating)
        }
      }
      /**
       * 我们设定一个`vm._watcher`在Watcher的构造函数中
       * 因为之前说了, Watcher的作用之一就是监听变化 (另个一作用是初始化触发) 从而调用 $forceUpdate
       * e.g. 在组件内部callHook的触发, 都依赖Watcher
       */
      new Watcher(vm, updateComponent, noop, {
        before () {
          if (vm._isMounted) {
            callHook(vm, 'beforeUpdate')
          }
        }
      }, true /* isRenderWatcher */) // 二参: 是否为渲染watcher
      hydrating = false
      /**
       * 手动挂载
       * 在组件render-created的时候,自动触发mounted
       * @_isMounted 区分: 未挂载,已挂载,再次渲染
       */
      if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
      }
      return vm
    }
```
对组件来说, 将vNode patch到Dom之后, 会执行`invokeInsertHook`, 把`insertedVnodeQueue`中保存的钩子都执行一遍;
`insertedVnodeQueue`对节点添加的顺序是: 先子后父, 所以钩子函数执行的顺序也是先子后父;
because: `createComponent(vnode, insertedVnodeQueue, parentElm, refElm)`中, 会指定父节点, 如果没父节点,就指定一个默认占位的节点; 所以一定是先添加子, 后添加父;

这也是为什么父子嵌套的时候,执行顺序是: 父beforeMount ▶️ 子beforeMount ▶️ 子 mounted ▶️ 父mounted

### beforeUpdate & updated
beforeUpdate 和 updated, 在数据更新的时候执行;
在组件的`mountComponent`中,会创建一个Watcher,在这个侦听器中,写入了beforeUpdate的钩子;
实际上是: 组件已经`mounted`的时候,才会去调这个钩子`beforeUpdate`

`updated`的执行是在`flushSchedulerQueue`中,只有满足vm.watcher和mounted两个状态才会触发;
即: 已经渲染完毕, 并且设定一个watcher重新监听变化 => 视为渲染完毕

??? 这里感觉有一些问题

### beforeDestroy & destroyed
在销毁的阶段执行

```js
  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    /**
     * 将自己从父组件中移除
     */
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    /**
     * 接触监听
     */
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    /**
     * 删除数据的引用 (observer)
     * 冻结没有被观察的对象
     */
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    vm._isDestroyed = true
    /**
     * 在当前的渲染树上, 调用移除的hook
     * 移除vNode节点
     */
    vm.__patch__(vm._vnode, null)
    callHook(vm, 'destroyed')
    // 移除所有的监听
    vm.$off()
    // 移除 __vue__ 的引用
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // 将父级置空
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
```
