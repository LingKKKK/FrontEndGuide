
数据响应式中,数据收集的目的就是为了触发对应的更新操作

# 派发和更新依赖setter方法
```js
  // defineReactive: 响应式
  export function defineReactive (
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
  ) {
    const dep = new Dep() // 声明一个Dep实例

    const property = Object.getOwnPropertyDescriptor(obj, key)
    if (property && property.configurable === false) {
      return
    }

    // cater for pre-defined getter/setters
    const getter = property && property.get
    const setter = property && property.set
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key]
    }

    let childOb = !shallow && observe(val)
    // 如果shallow为false, 会创建一个响应式对象 observe
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      // ...
      set: function reactiveSetter (newVal) {
        const value = getter ? getter.call(obj) : val
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return
        }
        /* eslint-enable no-self-compare */
        if (process.env.NODE_ENV !== 'production' && customSetter) {
          customSetter()
        }
        if (setter) {
          setter.call(obj, newVal)
        } else {
          val = newVal
        }
        childOb = !shallow && observe(newVal)
        // 通知所有订阅者更新
        dep.notify()
      }
    })
  }
```

# 过程分析
每次数据变更, 就会触发setter逻辑, 最后通过 dep.notify() 触发订阅更新;
dep是引入的 Dep 实例; 在`src/core/observer/dep.js`中定义
```js
  // Dep实例
  class Dep {
    // ...
    notify () {
      /**
       * 遍历subs, 这个subs就是Watcher的实例数组, 然后调用他们的update方法
       * 就是调用每一个watcher实例的update方法
       */
      const subs = this.subs.slice()
      for (let i = 0, l = subs.length; i < l; i++) {
        subs[i].update()
      }
    }
  }
```
Watcher实例下的update方法, 在`src/core/observer/watcher.js`中定义
```js
  class Watcher {
    // ...
    update () {
      if (this.computed) {
        /**
         * 计算属性的观察程序有两种模式: 惰性模式和响应模式(活性/非惰性) >>> lazy activated
         * 默认情况下是惰性模式, 并且至少一个订阅者进行订阅(subscriber)时, 才会将其激活;
         * 通常这个订阅者是计算属性, 或者组件的渲染函数
         * ∴ 计算属性属于被动触发, 只有被观察在会被执行, 可能是为了提升性能,减少不必要的损耗
         */
        if (this.dep.subs.length === 0) {
          /**
           * 在惰性模式下,必要时才会去对其进行计算;
           * 将它的观察者标记为脏数据; (dirty是watcher的一个属性, 为true时重新计算, 为false时使用缓存)
           * 当计算属性被访问时,会实时进行计算
           */
          this.dirty = true
        } else {
          /**
           * 在响应模式下, 他的真正改变时, 主动通知订阅者
           * 在Vue1.x中, 只要有改变动作就视为改变; 在Vue2.x后续修复了这个问题, 当值真的发生变化时才会去触发订阅者的更新
           */
          this.getAndInvoke(() => {
            this.dep.notify() // 主动触发wathcer的通知
          })
        }
      } else if (this.sync) {
        // sync的场景: 参考sync
        this.run()
      } else {
        /**
         * 组件的更新场景会进入到一个watcher队列中
         */
        queueWatcher(this)
      }
    }
  }
```
watcher队列`queueWatcher`在`src/core/observer/scheduler.js`中定义.
```js
  /**
   * 引用了队列的概念, 这是Vue做派发更新的优化点, 不会每次派发都立即执行回调, 会将其放入队列中;
   * 在nextTick之后执行 flushSchedulerQueue: 刷新队列调度任务
   */
  const queue: Array<Watcher> = [] // watcher队列
  let has: { [key: number]: ?true } = {} // 缓存集合
  let waiting = false // 是否等待
  let flushing = false // 是否已刷新
  /**
   * 将观察者都放入观察者队列中
   * 对于id重复的watcher会被忽略/跳过, 除非在刷新队列时已经将其添加进队列中 >>> 已经添加的ID会继续保留, 不会被重复添加
   */
  export function queueWatcher (watcher: Watcher) {
    const id = watcher.id // 读取watcher中的id
    if (has[id] == null) { // 如果has中没有此id
      has[id] = true // 将其添加到has中
      if (!flushing) {
        queue.push(watcher)
      } else {
        /**
         * 如果已经刷新, 会根据其id拼接观察者
         * 如果已经超过了他的id, 就立即执行
         */
        let i = queue.length - 1
        while (i > index && queue[i].id > watcher.id) {
          i--
        }
        queue.splice(i + 1, 0, watcher)
      }
      // queue the flush
      if (!waiting) {
        waiting = true
        nextTick(flushSchedulerQueue)
      }
    }
  }
```

