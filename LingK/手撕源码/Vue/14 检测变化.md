# 检测数据
检测数据是依赖getter和setter方法, 但是特殊的情况可能不生效

## 给对象添加属性
基于Object.defineProperty属性实现响应式的对象,当我们给这个对象添加新的属性时,是无法触发setter方法.
```js
  var vm = new Vue({
    data:{
      a:1
    }
  })
  // vm.b 是非响应的
  vm.b = 2
```
这种情况很常见,我们经常需要在一个对象上添加新的属性,但是这个属性是不响应的.解决方法是调用`$set`方法.
```ts
  /**
   * 设置对象的属性时, 如果这个属性不存在, 就会触发更改通知
   * @target 目标对象
   * @key 属性名
   * @value 属性值
   */
  export function set (target: Array<any> | Object, key: any, val: any): any {
    if (process.env.NODE_ENV !== 'production' &&
      (isUndef(target) || isPrimitive(target))
    ) {
      // 判断目标是否存在, 如果是空对象或者是原始值, 则抛出异常 -> 无法对未定义的目标进行设置
      warn(`目标不存在无法定义: ${(target: any)}`)
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      // 如果目标是数组, 并且key是一个合法的下标, 则直接赋值
      target.length = Math.max(target.length, key)
      target.splice(key, 1, val)
      return val
    }
    if (key in target && !(key in Object.prototype)) {
      // 下标存在直接替换
      target[key] = val
      return val
    }

    // __ob__/observer属性: 标识当前对象被观测了
    const ob = (target: any).__ob__ // 将原有的观测方法赋值到当前目标对象

    if (target._isVue || (ob && ob.vmCount)) {
      process.env.NODE_ENV !== 'production' && warn(
        'Avoid adding reactive properties to a Vue instance or its root $data ' +
        'at runtime - declare it upfront in the data option.'
      )
      return val
    }
    if (!ob) {
      target[key] = val
      return val
    }
    defineReactive(ob.value, key, val) // 将新添加的属性变成响应式对象
    ob.dep.notify() // 触发依赖通知
    return val
  }
```

```js
  // 添加响应式
  export function defineReactive (
    obj: Object,
    key: string,
    val: any,
    customSetter?: ?Function,
    shallow?: boolean
  ) {
    // ...
    let childOb = !shallow && observe(val)
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter () {
        const value = getter ? getter.call(obj) : val
        if (Dep.target) {
          // 在 getter 过程中判断了 childOb，并调用了 childOb.dep.depend() 收集了依赖，这就是为什么执行 Vue.set 的时候通过 ob.dep.notify() 能够通知到 watcher，从而让添加新的属性到对象也可以检测到变化。这里如果 value 是个数组，那么就通过 dependArray 把数组每个元素也去做依赖收集。
          dep.depend()
          if (childOb) {
            childOb.dep.depend()
            if (Array.isArray(value)) {
              dependArray(value)
            }
          }
        }
        return value
      },
      // ...
    })
  }
```

## 数组
上面提到, 如果是数组, 通过splice方法添加新的属性, 则会触发数组的更新通知.
```js
  export class Observer {
    constructor (value: any) {
      this.value = value
      this.dep = new Dep()
      this.vmCount = 0
      def(value, '__ob__', this)
      if (Array.isArray(value)) {
        const augment = hasProto // hasProto -> 判断是否存在 __proto__ 属性
          ? protoAugment
          : copyAugment
        augment(value, arrayMethods, arrayKeys)
        this.observeArray(value)
      } else {
        // ...
      }
    }
  }
```
也是通过`__ob__`属性来标识当前对象是否被观测了.

```js
// 判断数组是否被观测, 通过__proto__方法来判断
function protoAugment (target, src: Object, keys: any) {
  // 将`target.__proto__`的原型,指向`src`
  target.__proto__ = src
}
function copyAugment (target: Object, src: Object, keys: Array<string>) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    // 遍历,通过def方法(Object.defineProperty)定义自身的属性值; 就是为了实现依赖收集
    // 因为已经存在`__proto__`属性的对应已经代表被观测了, 所以不需要再次观测
    def(target, key, src[key])
  }
}
```
