# 组件更新
当数据发生变化时, 会触发渲染`watcher`的回调函数, 进而执行组件的更新过程
```js
  // 更新组件的方法
  updateComponent = () => {
    vm._update(vm._render(), hydrating) // 调用vm._update方法
  }
  // 触发Watcher, 执行更新
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
```

```js
  // _update方法
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this // 挂载组件的实例
    // ...
    const prevVnode = vm._vnode
    if (!prevVnode) {
      // 初始化的时候, 没有prevVnode
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // 更新的时候, 有prevVnode
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    // ! 均是通过vm.__patch__方法更新的
    // ...
  }
```

```js
  /**
   * @patch函数 对比组件节点之间的差异
   * @patch函数的执行过程
   */
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    /**
     * @isUndef 判断是否为 undefined/null
     * @isDef 是否不为 unfefined/null
     * @invokeDestroyHook 销毁组件的钩子
     */
    if (isUndef(vnode)) {
      // 如果新节点未定义,旧节点已定义,则调用销毁钩子 -> 销毁旧节点
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false // 作为参数传入`invokeInsertHook`中 & ture -> 销毁
    // 插入虚拟节点的队列数组
    const insertedVnodeQueue = []

    // 如果虚拟节点不存在
    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element -> 创建一个新的根节点挂载
      // 标记当前的虚拟节点为:已创建, 只存在于内存中,并不挂载于DOM
      isInitialPatch = true
      // 将新的虚拟节点转换成真实的DOM
      createElm(vnode, insertedVnodeQueue)
    } else {
      // 如果存在`nodeType`属性, 则说明是一个真实的DOM节点
      const isRealElement = isDef(oldVnode.nodeType)
      /**
       * ! sameVnode
       * 如果两个vNode和key不相等, 则视为不同; 否则继续向下判断
       * 同步组件: 判断isComment、data、input类型是否相同
       * 异步组件: 判断asyncFactory是否相同
       */
      // 如果不是真实的DOM节点,并且新旧节点相同
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // 调用`patchVnode`方法,通过diff算法,对比新旧节点的差异并更新
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
      } else {
        // 如果是真实DOM节点 或者 新旧节点不相同
        if (isRealElement) {
          // ...
          oldVnode = emptyNodeAt(oldVnode);
          // 将真实的DOM转换成虚拟节点, 并赋值给旧的虚拟节点
        }
        // replacing existing element -> 替换现有的节点

        // 获取旧虚拟节点的真实DOM元素
        const oldElm = oldVnode.elm
        // 获取旧虚拟节点父级元素节点
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        // 调用`createElm`方法,将新的虚拟节点转换成真实DOM元素,并挂载到父元素节点上
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively -> 递归更新父元素中的占位符节点
        // ! 这一步是将新创建的节点替换到旧节点的父元素中
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              // 遍历父元素的节点module中的销毁钩子
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              // 如果当前占位符是可挂载的
              for (let i = 0; i < cbs.create.length; ++i) {
                //  调用create方法进行创建挂载
                cbs.create[i](emptyNode, ancestor)
              }
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              // 重新注册
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // 如果存在旧的虚拟节点的父元素节点
        if (isDef(parentElm)) {
          // 移除对应的真实DOM节点
          removeVnodes(parentElm, [oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          // 如果不存在真实DOM节点,但是存在Tag,就调用销毁钩子
          invokeDestroyHook(oldVnode)
        }
      }
    }

    // 遍历`插入虚拟节点的队列数组`, 执行insert钩子
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
```

## 对比节点是否相同
  ① vNode(tag)和key不相同 -> 不同节点
  ② vNode(tag)和key不相同 -> 不同节点
     ① 同步组件 -> 判断: isComment、data、input类型是否相同
     ② 异步组件 -> 判断: asyncFactory是否相同

### 新旧节点不同时
  本质上要替换已经存在的节点
  ① 创建新的节点
    `createElm`方法, 以旧节点为参考, 创建新的节点并插入到DOM中
  ② 更新父节点中的占位符节点(将新节点替换)
    1. 找到`vnode`的`父占位符节点`
    2. 遍历`父占位符节点`的module, 执行`destory`钩子函数 && 如果`当前占位符`是一个`可挂载节点`, 执行`creat`钩子函数
  ③ 删除旧节点
    1. 把`oldVnode`从当前`DOM树`中删除
    2. 如果`父元素`存在, 调用`removeVnodes`方法
      遍历待删除的`vnodes`节点调以下方法:
        `removeAndInvokeRemoveHook`: 递归执行`module`中的`remove`钩子
        `invokeDestroyHook`: 递归执行`vNode`中的`destory`钩子
        `removeNode`: 调用平台的DOM API, 将真实的DOM移除掉

### 新旧节点相同时
  调用`patchVNode`方法, 把新的`vNode` `patch`到`旧的vNode`上, 核心逻辑如下:
  prepatch => update => patch => postpatch

  ① 执行`prepatch`钩子函数
    1. 获取到新的`组件配置`和`组件实例`
    2. 调用`updateChildComponent`更新组件中的方法: vnode、slot、props、listener等
  ② 执行`update`钩子函数
  ③ 执行`patch`方法
    * 对各类清空进行判断
    1. `新旧组件`都`存在`&`不相等`时,使用`updateChildren`更新子组件
    2. 如果只有`新组件`,表示`旧组件`不再需要,清除`旧组件`文本内容,批量插入到`新组件下`
    3. 如果只有`旧组件`,表示更新为空.调用`removeVnodes`方法全部清除掉
    4. 如果只有`旧节点`&为文本节点,清空内容即可
  ④ 执行`postpatch`钩子函数
    组件的自定义钩子函数,有就执行,没有跳过

#### updateChildren -> patch过程中比较重要的方法
  这是Vue diff的核心算法
  Vue的双向链表比较也在此方法中体现

  参考: `other - diff核心算法.md` 中的`updateChildren`方法
