# 组件化

Vue的另一个核心思想就是: 组件化;
所谓的组件化, 就是把页面拆分成多个组件(component), 每个组件依赖的css,js,模板,等资源都在一起开发维护;
组件是相互独立的,在系统内部可以重复使用的,组件和组件之间可以嵌套;
使用组件开发,就想搭积木一样,将组件拼成一个个页面,页面再拼成产品;

## createComponent

在创建vNode节点时,会调用`_createElement`方法;
会对`tag`进行判断,如果是一个普通的`html`标签,会实例化一个普通的vNode节点;
否则会通过`createComponent`来创建一个`组件的vNode节点`
```js
    if (typeof tag === 'string') {
      /**
       * ! 没看懂这个声明
       * 分析一下:
       */
      let Ctor
      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)

      if (config.isReservedTag(tag)) {
        // 可以解析tag就生成vnode节点
        vnode = new VNode(
          config.parsePlatformTagName(tag), data, children,
          undefined, undefined, context
        )
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        /**
         * 解析逻辑: isDef(Ctor = resolveAsset() => 解析生成组件的vnode
         * 在`src/core/utils/options.js`中定义
         * 会依次对`id`进行判断, 连字符/驼峰/大驼峰; 这也是为什么组件能支持多写法的原因(兼容性)
         * 如果能成功解析出componentVnode就将其作为 createComponent 的参数
         */
        vnode = createComponent(Ctor, data, context, children, tag)
      } else {
        /**
         * ! 这里应该是生成一个默认的vnode节点
         * 对于无命名空间的元素, 最起码要默认分配一个命名空间
         * ? 子节点规范类型: 是父节点来规范子节点的类型 ????  不太确定
         * parent normalizes children -> 自己的理解: 通过上层命名下层;例如: customer, customer_1
         */
        vnode = new VNode(
          tag, data, children,
          undefined, undefined, context
        )
      }
    } else {
      // 如果解析到的是组件, 就生成组件的vNode节点: options / constructor
      vnode = createComponent(tag, data, context, children)
    }
```

组件都是通过`createComponent`来实现解析的;
在`src/core/vdom/create-component.js`中:
```js
    export function `createComponent` (
      Ctor: Class<Component> | Function | Object | void,
      data: ?VNodeData,
      context: Component,
      children: ?Array<VNode>,
      tag?: string
    ): VNode | Array<VNode> | void {
      /**
       * 允许传入5个参数
       * @Ctor 是一个构造函数 / Vue.extend构建的子类 ;;;  不太确定 ???
       *       传入的是:组件/构造/对象; 最终会将其转换成一个构造函数
       * @data 标识vNode的数据
       * @context 上下文环境
       * @children 子节点(也是任意类型 -> 套娃)
       * @tag 标签,是一个字符串,也可以是Component
       */
      /**
       * isUndef 判断是否未定义; return params === undefined || params === null
       */
      if (isUndef(Ctor)) {
        return
      }
      /**
       * context.$options._base 实际上就是Vue
       * @initGlobalAPI 函数中定义 => Vue.options._base = Vue
       * baseCtor 指向 => Vue; 拿到了Vue的构造函数
       */
      const baseCtor = context.$options._base
      /**
       * 如果是对象, 将其转化为构造函数;
       * * 从上下文环境中读取配置
       * ! 1.构造子类构造函数
       */
      if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor)
      }
      /**
       * 如果执行到这里, 判断Ctor不是`构造函数 || 异步组件`, 就进行阻止
       */
      if (typeof Ctor !== 'function') {
        if (process.env.NODE_ENV !== 'production') {
          warn(`无效的组件定义: ${String(Ctor)}`, context)
        }
        return
      }
      /**
       * 异步组件 async component
       * @resolveAsyncComponent 解析异步组件, 返回 数据/上下文/标签/组件信息等内容
       * 如果无法解析异步组件, 就会分配一个默认的占位用的注释节点(包含所有信息, ssr)
       */
      let asyncFactory
      if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
        if (Ctor === undefined) {
          /**
           * 如果未解析出该异步组件
           * return a placeholder node for async component, which is rendered as a comment node but preserves all the raw information for the node.the information will be used for async server-rendering and hydration.
           * 会返回异步组件的占位符节点; 该节点呈现为注释节点, 但是保留所有的节点信息;
           * 这些信息将用于异步ssr和hydration(水车?水瀑?)
           */
          return createAsyncPlaceholder(
            asyncFactory,
            data,
            context,
            children,
            tag
          )
        }
      }
      data = data || {}
      /**
       * resolve constructor options in case global mixins are applied after component constructor creation
       * 在组件构造函数创建后, 并使用全局混入的情况下 => 解析构造函数
       * @resolveConstructorOptions 解析构造函数的选项
       */
      resolveConstructorOptions(Ctor)
      /**
       * transform component v-model data into props & events
       * 转换组件绑定v-model的value => props和event
       */
      if (isDef(data.model)) {
        transformModel(Ctor.options, data)
      }
      /**
       * 提取信息 => props
       * @extractPropsFromVNodeData 字面量理解, 就是从节点的数据中, 提取出props;
       * 从这里可以体现出语义化命名的好处, 不需要写任何注释, 也不需要进入函数即可猜出其逻辑
       */
      const propsData = extractPropsFromVNodeData(data, Ctor, tag)

      /**
       * 函数化组件? | 功能化组件? function译为:函数/功能
       */
      if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children)
      }
      /**
       * extract listeners, since these needs to be treated as child component listeners instead of DOM listeners
       * 提取侦听器 => 侦听子组件, isn't for DOM
       */
      const listeners = data.on
      /**
       * replace with listeners with .native modifier so it gets processed during parent component patch.
       * 替换为带有本机修饰符的监听者;;;
       * 在组件进行patch的阶段, 触发监听, 对其进行处理;
       */
      data.on = data.nativeOn
      /**
       * 组件最后都会转换成AST
       * 编译其实就是: 提取vNode => 生成AST => 优化AST => 渲染vDOm
       */
      if (isTrue(Ctor.options.abstract)) {
        /**
         * abstract components do not keep anything other than props & listeners & slot
         * 抽象组件AST, 仅保存 props/listener/slot
         * 调用flow进行语法检查
         */
        const slot = data.slot
        data = {}
        if (slot) {
          data.slot = slot
        }
      }
      /**
       * install component management hooks onto the placeholder node
       * 在占位节点中, 挂载hooks
       * ! 2.安装组件钩子函数
       */
      installComponentHooks(data)
      /**
       * return a placeholder vnode
       * 安装完毕之后, 将占位节点返回出去
       * ! 3.实例化vNode节点
       */
      const name = Ctor.options.name || tag
      const vnode = new VNode(
        `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
        data, undefined, undefined, undefined, context,
        { Ctor, propsData, listeners, tag, children },
        asyncFactory
      )
      // Weex specific: invoke recycle-list optimized @render function for
      // extracting cell-slot template.
      // https://github.com/Hanks10100/weex-native-directive/tree/master/component
      /* istanbul ignore if */
      /**
       * @isRecyclableComponent 判断是否为可回收组件
       * @renderRecyclableComponentTemplate 渲染可回收组件
       */
      if (__WEEX__ && isRecyclableComponent(vnode)) {
        return renderRecyclableComponentTemplate(vnode)
      }

      return vnode
    }
```
主要有3个核心的步骤:
- 构造子类构造函数
- 安装组件钩子函数
- 实例化vNode

### 构造子类构造函数
我们在编写组件的时候, 通常都会创建一个普通的对象, 以App.vue为例,
```js
  import HelloWorld from './components/HelloWorld'
  export default {
    name: 'app',
    components: {
      HelloWorld
    }
  }
```
这里`export`的是一个对象, 所以createElement里的代码就会执行到`isObject()`的判断;
Vue.extend:
- 作用: 构造一个Vue的子类 (使用原型继承的方式; 纯对象 ==> 继承构造器 ==> return一个构造器Sub)
- 对子类进行一些拓展: options 全局API
- 初始化工作: props, computed等
- 对构造函数Sub做缓存, 避免重复执行

### 安装组件钩子函数
Vue的`Virtual Dom`使用的snabbdom的库, 他的特点就是: 在vNode的patch流程中, 对外暴露很多钩子, 方便做一些额外的事情.
所以, Vue在初始化一个component类型的vNode的过程中, 实现了几个钩子;

`installComponentHooks`的过程:
  - 将`componentVNodeHooks`中的钩子函数, 合并到`data.hook`中
  - 在vNode执行patch的过程中执行相关的钩子函数
  - 如果一个钩子存在于data.hooks中, 另一个通过mergeHooks合并, 执行时顺序执行即可;

### 实例化vNode
实例化vNode节点并返回出去
