## 组件注册

除了一些内置的组件(keep-alive、component、transition)等, 其他组件在使用之前都需要注册;

一个Vue项目可以有很多实例, 每一个组件都可以是一个实例, 但是main.js中只允许一个实例就是全局的Vue;
Vue可以看成,是N个组件拼装成一个项目;

## 全局注册

要注册一个全局组件，可以使用 [Vue.component(tagName, options)](https://cn.vuejs.org/v2/api/#Vue-component)
```js
    // 注册组件，传入一个扩展过的构造器
    Vue.component('my-component', Vue.extend({ /* ... */ }))
    // 注册组件，传入一个选项对象 (自动调用 Vue.extend)
    Vue.component('my-component', { /* ... */ })
    // 获取注册的组件 (始终返回构造器)
    var MyComponent = Vue.component('my-component')
```
在`src/core/global-api/assets.js`中,定义了Vue.component的方法:
```js
    import { ASSET_TYPES } from 'shared/constants'
    import { isPlainObject, validateComponentName } from '../util/index'

    export function initAssetRegisters (Vue: GlobalAPI) {
      /**
       * Create asset registration methods.
       * 创建注册的方法
       * definition:定义、方法
       */
      ASSET_TYPES.forEach(type => {
        /**
         * 遍历`ASSET_TYPES`, 得到type之后挂载到Vue下 Vue[type] = xxx
         * ASSET_TYPES在Vue内部定义，var ASSET_TYPES = ['component','directive','filter'];
         */
        Vue[type] = function (
          id: string,
          definition: Function | Object
        ): Function | Object | void {
          /**
           * 这里的definition指的是定义（Function或Object），是函数或者对象
           * 如果definition不存在，直接返回 options内type和id对应的内容
           * options: 全局的组件，指令和过滤器 [可全局打印, 就是Component下的几个类型]
           */
          if (!definition) {
            return this.options[type + 's'][id]
          } else {
            if (process.env.NODE_ENV !== 'production' && type === 'component') {
              validateComponentName(id)
            }
            /**
             * 传入对象时, 使用Vue.extend()将对象转换成一个继承于Vue实例的构造函数;
             * 传入函数时, 已经调用过Vue.extend(), 直接返回即可
             * 当声明'自定义指令'时, 给他添加 bind 和 update 调用 ??? 不太清楚
             * this.options._base.extend 就是 Vue.extend
             */
            if (type === 'component' && isPlainObject(definition)) {
              definition.name = definition.name || id
              definition = this.options._base.extend(definition)
            }
            if (type === 'directive' && typeof definition === 'function') {
              definition = { bind: definition, update: definition }
            }
            /**
             * !将组件挂载到全局的 Vue.options.components 上
             * 确保所有的实例都可以调用到
             */
            this.options[type + 's'][id] = definition
            /**
             * 已将全局组件,指令,过滤器 统一挂载到 vue.options 上
             * 等待init的时候 merge options
             * 执行完毕 mergeOptions 之后, 才做到入侵全局实例, 实现调用
             */
            return definition
          }
        }
      })
    }
```
```js
    /**
     * Vue初始化了三个全局函数,
     */
    export const ASSET_TYPES = [
      'component',
      'directive',
      'filter'
    ]
    /**
     * @实例化的过程
     * 1. 通过`mergeOptions`的方法, 将Vue.options合并到`实例化对象的options`上;
     * 2. 创建vNode的过程中,会执行`_createElement` -> `src/core/vdom/create-element.js`
     * @Sub 就是实例化的组件
     * 最后, 将 Sub.$options.components 合并到 -> vm.$options.components
     */
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    也就是说它会把 Vue.options 合并到 Sub.options，也就是组件的 options 上， 然后在组件的实例化阶段，会执行 merge options 逻辑，把 Sub.options.components 合并到 vm.$options.components 上。
```
```js
    /**
     * _createElement: src/core/vdom/create-element.js -> 创建vnode节点调用
     * 在组件化中有源码分析, 就是为了创建 componentVnode节点
     */
```


## 局部注册

Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 components 选项做组件的局部注册，例如：

```js
  import HelloWorld from './components/HelloWorld'

  export default {
    components: {
      HelloWorld
    }
  }
```
把component合并到`vm.$options.components`上, 这样可以在`resolveAsset`解析资源的时候,拿到这个组件的构造函数, 并作为`createComponent`的钩子函数

## 区别
在组件创建的过程中, 都会从全局的`Vue.options.component`扩展到当前组件的`Vue.options.component`;
这就是全局组件能被任意组件使用的原因;


## Vue.extend 是如何处理的 ???
[参考](https://www.jb51.net/article/146210.htm)
```js
Vue.extend = function (extendOptions) {
  /**
   * extendOptions是组件的配置项  data? props? el? template?
   */
  extendOptions = extendOptions || {};
  var Super = this;
  var SuperId = Super.cid;
  //组件缓存
  var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
  //如果组件已经被缓存在extendOptions上则直接取出
  if (cachedCtors[SuperId]) {
    return cachedCtors[SuperId]
  }
  //如果有name属性，检验name拼写是否合法
  var name = extendOptions.name || Super.options.name;
  if ("development" !== 'production' && name) {
    validateComponentName(name);
  }
  var Sub = function VueComponent (options) {
    this._init(options);
  };
  //将vue上原型的方法挂在Sub.prototype中，Sub的实例同时也继承了vue.prototype上的所有属性和方法。
  //关于 prototype的学习：http://www.cnblogs.com/dolphinX/p/3286177.html
  Sub.prototype = Object.create(Super.prototype);
  //Sub构造函数修正，学习于https://www.cnblogs.com/SheilaSun/p/4397918.html
  Sub.prototype.constructor = Sub;
  Sub.cid = cid++;
  /**
   * 通过vue的合并策略合并添加项到新的构造器上
   * todo: 每个组件都是通过这样方法 => 实现继承
   */
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  );
  //缓存父构造器
  Sub['super'] = Super;
  // 处理props和computed响应式配置项
  if (Sub.options.props) {
    initProps$1(Sub);
  }
  if (Sub.options.computed) {
    initComputed$1(Sub);
  }
  // allow further extension/mixin/plugin usage
  Sub.extend = Super.extend;
  Sub.mixin = Super.mixin;
  Sub.use = Super.use;
  //在新的构造器上挂上vue的工具方法
  ASSET_TYPES.forEach(function (type) {
    Sub[type] = Super[type];
  });
  // enable recursive self-lookup
  if (name) {
    Sub.options.components[name] = Sub;
  }
  /**
   * 在扩展时保留super配置。
   * 稍后在实例化时，我们可以检查Super的选项是否已更新。
   * 没看懂是干啥的
   */
  Sub.superOptions = Super.options;
  Sub.extendOptions = extendOptions;
  Sub.sealedOptions = extend({}, Sub.options);
  //缓存组件构造器在extendOptions上
  cachedCtors[SuperId] = Sub;
  return Sub
 };
```
