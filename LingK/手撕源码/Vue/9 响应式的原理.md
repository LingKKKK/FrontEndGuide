

## 深入响应式原理
Vue的工作集中在初始化的阶段, 在初始化时绑定好了依赖关系和监听;将原始的数据最终映射到DOM层;
响应式一个重要的体现就是: 数据的变化会触发DOM的更新

前端开发的工作内容就是:
1. 把数据渲染到页面上
2. 处理用户和页面的交互
* 涉及到了初始化渲染, 和动态渲染

```html
    <div id="app" @click="changeMsg">
      {{ message }}
    </div>
```
```js
    var app = new Vue({
      el: '#app',
      data: {
        message: 'Hello Vue!'
      },
      methods: {
        changeMsg() {
          this.message = 'Hello World!'
        }
      }
    })
```
响应式: 我们在修改 this.message 的时候, 模板会对应的插入变更新的数据;

先分析一下,我们不依赖Vue是如何实现响应式效果的?
  1. 监听数据
  2. 修改数据到DOM元素上
  3. 手动更新DOM元素 (Vue不需要手动更新,因为自动绑定了依赖关系)

Vue内部帮我们实现了:
  1. 需要修改哪一块DOM?
  2. 修改的效率和性能是否为最优?
  3. 需要对数据的每一次操作都进行修改么?
  4. 需要 case by case 的去修改DOM逻辑么?
  * Vue双向绑定的的特性

响应式实现的过程:
  - 依赖收集 getter
    1. init 初始化 (data props state)
    2. 确定依赖收集关系: `Observer-Watcher-Dep`
    -  递归对象(Array/Object), 调用 `defineReactive/observeArray` 方法, 确保所有属性有 __ob__;
    -  Observer: 给数据设置的观察器, 用于数据劫持 `__ob__`
    -  Watcher:  `系统的观察者(是观察者模式的载体)`; 用于观察一个属性的更新和获取的类 `vm._watcher`
    -  Dep:      一个用于管理 Watcher 的类 `dep.target/depid`
  - 派发更新 setter
