# 导航守卫

**完整的导航流程**

全局前置守卫  beforeEach
全局解析守卫  beforeResolve
全局后置守卫  afterEach
路由独享守卫  beforeEnter
组件内的守卫  beforeRouteEnter  beforeRouteUpdate beforeRouteLeave

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 守卫。
3. 调用全局的 beforeEach 守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
5. 在路由配置里调用 beforeEnter。
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。
8. 调用全局的 beforeResolve 守卫(2.5+)。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

# 路由元信息

将部分通用信息追加在路由上, 例如: 访问权限 auth. 将这些信息追加到 meta 属性上.
在meta属性上的内容,可以通过*this.$route*来访问到. 也可以在所有的导航守卫中检测到.

```js 设置meta属性
const routes = [
  {
    path: '/posts',
    component: PostsLayout,
    children: [
      {
        path: 'new',
        component: PostsNew,
        // 只有经过身份验证的用户才能创建帖子
        meta: { requiresAuth: true }
      },
      {
        path: ':id',
        component: PostsDetail
        // 任何人都可以阅读文章
        meta: { requiresAuth: false }
      }
    ]
  }
]
```
```js 在路由守卫中查询meta信息
router.beforeEach((to, from) => {
  // 而不是去检查每条路由记录
  // to.matched.some(record => record.meta.requiresAuth)
  if (to.meta.requiresAuth && !auth.isLoggedIn()) {
    // 此路由需要授权，请检查是否已登录
    // 如果没有，则重定向到登录页面
    return {
      path: '/login',
      // 保存我们所在的位置，以便以后再来
      query: { redirect: to.fullPath },
    }
  }
})
```
```typescript 在 d.ts 文件追加meta属性
router.beforeEach((to, from) => {
  // 而不是去检查每条路由记录
  // to.matched.some(record => record.meta.requiresAuth)
  if (to.meta.requiresAuth && !auth.isLoggedIn()) {
    // 此路由需要授权，请检查是否已登录
    // 如果没有，则重定向到登录页面
    return {
      path: '/login',
      // 保存我们所在的位置，以便以后再来
      query: { redirect: to.fullPath },
    }
  }
})
```

# 数据获取

**根据实际的场景, 结合路由钩子, 判断调用的时机**
有些需要在导航之前, 加载基本信息等
有些需求在导航之后, 根据当前页面的id, 加载列表信息等

# 组合式 API

**配合Vue3一起看**

# 过渡效果

**meta配合transition标签一起使用**

# 滚动行为

*场景* 在进入到页面之后,默认滚动到某一位置
route的`scrollBehavior`方法是触发滚动的api
*改造* 通过`Promise`可将其封装成一个延时效果

# 路由懒加载

当构建应用的时候, JavaScript的包会变的非常大, 影响页面的加载.
如果把不同路由对应的组件分割成不同代码块, 在访问时再加载对应组件, 这样会节省资源.

```js 路由懒加载
// import UserDetails from './views/UserDetails.vue'
// 替换成
const UserDetails = () => import('./views/UserDetails.vue')
const router = createRouter({
  // ...
  routes: [{ path: '/users/:id', component: UserDetails }],
})
```

`component`和`components`接收一个返回`Promise`的函数, 仅在进入时触发一次.加载之后会被缓存起来.
**不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的**

# 导航故障

# 动态路由
对路由的添加通常通过`routes`选项来完成.
可通过`router.push()`,`router.replace()`来手动导航

```js
router.addRoute({ path: '/about', name: 'about', component: About })
// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的
router.addRoute({ path: '/other', name: 'about', component: Other })
```

*路由名称冲突* : 替换
*路由名称不冲突* : 添加

```js
const removeRoute = router.addRoute(routeRecord)
removeRoute() // 删除路由如果存在的话
```

## 查看路由

*router.hasRouter()* : 检查路由是否存在
*router.getRouters()* : 获取一个包含有所路由记录的数组
