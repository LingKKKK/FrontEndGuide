https://github.com/gweid/vue-source-code
https://vuex.vuejs.org/zh/

Vuex 是一个专为 Vue.js 应用程序开发的`状态管理模式`。 (数结构、状态管理模式 + 库)
它采用`集中式存储管理应用`的所有组件的状态，并`以相应的规则`保证`状态`以一种`可预测`的方式发生变化。

# 状态管理模式

```js 状态管理模式-Vue计数器
const Counter = {
  // 状态: 驱动应用的数据源
  data() {
    return {
      count: 0,
    };
  },
  // 视图: 以声明的方式将`状态`映射到视图上
  template: `
    <div>{{ count }}</div>
  `,
  // 操作: 响应在`视图`上的用户操作导致状态发生变化
  methods: {
    increment() {
      this.count++;
    },
  },
};
createApp(Counter).mount("#app");
```

`状态`驱动`视图`,`视图`提供`操作`场景,`操作`触发`状态`更新; 这就是我们理想情况下的单向数据流;
当我们的应用遇到多个组件共享状态时, 单向数据流的简洁性容易被破坏.

- 多个视图组件依赖同一个状态
  e.g. `Theme Color`等全局配置,在根组件存储,作用在 N 层之下的子组件中
  传参的方法会根据组件层级的加深而变得繁琐, 并且对于兄弟组件之间的传递是无效的.
- 不同的视图行为需要统一变更
  通常会采用父子组件直接引用, 这样一来维护的成本比较大, 动辄就需要修改很多内容.
- ☆ 较理想的方式就是: 把组件的共享状态抽取出来, 以一个全局单例模式进行管理. 类似之前在即刻小程序中写的`global.js`. 这样组件树就构成了一张巨大的视图网络,不管哪个视图发生变化,不管那个数据发生改变, 任何模块任何组件都能够获取到状态或触发行为.

# 什么情况下应该使用 VueX?

VueX 的作用就是:帮助我们管理共享状态`globalData`,并附带了概念和框架等内容.并不像即刻小程序中`globalData.js`中实现的状态单例模式.
_需要我们对短期和长期效益进行权衡_

如果不打算开发大型单页面应用,使用 VueX 会伴随着逻辑繁琐冗余,让代码不够简洁.使用简单的 store 模式即可.
如果需要构建一个中大型单页面应用,且需要考虑如何在组件外部管理状态,VueX 就成为首选.

Redux 的作者说: Flux 架构就像是眼镜,你自然会知道什么时候使用它. 这对 VueX 同样适用.

# 最简单的 demo

让 VueX 运行起来,只需要给定初始 state 和一些 mutation 即可.
由此可知: 这两项是 VueX 中必须的属性.

```js
// TODO: 声明阶段
import { createApp } from "vue";
import { createStore } from "vuex";
const store = createStore({
  // 创建一个新的 store 实例
  state() {
    return {
      count: 0,
    };
  },
  mutations: {
    increment(state) {
      state.count++;
    },
  },
});
const app = createApp({
  /* 根组件 */
});
app.use(store); // 将 store 实例作为插件安装
// TODO: 使用阶段
store.commit("increment"); // commit触发mutation & dispatch触发action; 并非直接修改state
```

# Vuex 核心思想

Vuex 的应用核心就是`store`仓库. `store`就是一个容器, 包含了应用中大部分的状态.
这个和`全局对象`(定义一个全局对象,然后对外暴露接口)是比较形似.
`Vuex`和`全局对象`的区别: 1. `Vuex`的状态存储是响应式的, 当存入的数值发生变化时, 所依赖的视图会自动更新 2. 不能直接改变`store`中的状态, 修改数据的唯一途径就是显示的提交`commit(mutation)`, 这样更方便我们跟踪每此修改 3. `Vuex`从定义到隔离状态管理, 各种概念都是清晰的. 强制统一规则, 让代码的可维护性和结构性更强.

☆☆☆ 换言之: 自己定义的`全局对象`如果能解决: 1.reactive 2.规则 就可以做到完全替代

# VueX 核心概念

## state

VueX 使用的是`单一状态树`
从官网的描述中,我们可以看出,state 应该为: `纯粹代表组件状态的普通对象`.

**思考一下**: 为什么建议是普通对象? (和$vm.data 一样)
不建议使用一个能改变自身状态的对象,例如浏览器原生 API 或自带原型的类实例.
_不建议,并不是完全禁止_
_从 state 的粒度分析_: 期望将 state 划分成最小的粒度,如果你设置的 state 是复杂状态,拥有自身的属性和方法,第一不便于管理,第二它可以继续向下拆分成 state,没有必要集合在一个 state 进行托管.
_从数据结构分析_: 如果引用了复杂对象或者一个类,我们应该如何赋值呢? 直接赋值显然会破坏原有的数据结构,只能考虑通过 Object.assign 这类方式进行修改. 在保证数据结构的前提下,会增加维护的复杂度. 反之如果不考虑数据结构那就没必要使用一个复杂类.
_从 state 的特性来看_: 如果该对象能够改变自身,就不符合 VueX 数据唯一性的原则.

store.state.count 是一个计算属性,每次数据发生变化的时候,都会触发它的更新.
在 templete 中,也可以通过 this.$store.state.count 来访问

### mapState 辅助函数

mapState 返回一个对象,帮助开发者生成计算属性. 如果逐个获取的话,会十分的繁琐,一般 VueX 都存放大量的 state.

```js mapState的几种使用方式
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from "vuex";
export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: (state) => state.count,
    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: "count",
    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState(state) {
      return state.count + this.localCount;
    },
  }),
  // ...
  computed: mapState([
    // 映射 this.count 为 store.state.count
    'count'
  ])
  // ...
  computed: {
    ...mapState({
      // 使用对象展开运算符将此对象混入到外部对象中
    })
  }
};
```

## Getter

VueX 允许在 store 中定义`getter`(这个 getter 可以理解为:`store的计算属性`)
它和计算属性一样,getter 的返回值会根据它的依赖被缓存起来.
这是一个公用的方法,可以在多处直接调用,而不需要导入. 避免了大量重复的计算.

**注意**
在 VueX 中，getter 和 state 的命名最好不要重复, 会对使用和代码 review 有一些影响;
`例如:store.xxx 和 store.getter.xxx；`
因为 getter 下是派生的状态，虽然都是普通类型，但是意义各有不同，建议考虑实际场景遵循命名规则

### mapGetters 辅助函数

mapGetters 的作用是将 store 中的 getter 映射到局部计算属性. 和 mapGetters 的作用和返回值一样.

```js mapGetters的写法
import { mapGetters } from 'vuex'
export default {
  // ...
  computed: {
    ...mapGetters([ // 使用对象展开运算符将 getter 混入 computed 对象中
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
    // ...
    ...mapGetters({
      // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`
      doneCount: 'doneTodosCount'
    })
  }
}
```

## mutation

更改 VueX 的 store 中状态的唯一方式是提交`mutation`,VueX 中的`mutation`非常类似事件:
_每个 mutation 都有一个字符串的`事件类型:type`和一个`回调函数:handler`_
再触发的时候,不能直接操作这个函数或者 state,通过`store.commit('字符串名称')`来触发这个回调函数.

mutation 必须是`同步函数`; 因为异步流程,会让 state 状态变得不可追踪,无法及时的获取到 state 状态.

### 使用常量替代 mutation 事件类型

使用常量替代`Mutation`事件类型,在各种 Flux 实现中是很常见的

### mapMutations

我们可以使用`this.$store.commit('xxx')`的方法来提交`mutation`
或者使用`mapMutation`辅助函数将组件中的`methods`映射为`store.commit`来调用
`mapMutation`与`mapState`和`mapGetters`不同的地方是: `mapMutation`转换的是方法而不是状态
将`commit`方法映射到`methods`中

```js
import { mapMutations } from "vuex";
export default {
  // ...
  methods: {
    ...mapMutations([
      "increment", // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

      // `mapMutations` 也支持载荷：
      "incrementBy", // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ]),
    ...mapMutations({
      add: "increment", // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    }),
  },
};
```

## action

`action`和`mutation`类似,他们的区别是:

1. Action 提交的是 mutation,而不是直接修改 state 状态
2. Action 可以包含任意异步操作 (可以是同步/也可以是异步)

### mapActions

和`mapMutation`类似,`mapActions`也是将`dispatch`方法映射到`methods`中

```js
import { mapActions } from "vuex";
export default {
  // ...
  methods: {
    ...mapActions([
      "increment", // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`
      // `mapActions` 也支持载荷：
      "incrementBy", // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: "increment", // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    }),
  },
};
```

## Module

因为 VueX 的结构是`单一状态树`,所以应用的所有状态都会`集中到一个对象`中,当应用变得复杂时,store 对象会变得极其`臃肿`.
为了解决这个问题,VueX 允许`将store分割成模块(module)`
每个模块拥有自己的: `state`, `mutation`, `action`, `getter`, `module`

```js VueX结构
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = createStore({
  modules: { // moduleA 和 moduleB都作为子模块
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

### 命名空间

默认的情况下,模块内部的`mutation`和`actions`是注册在全局命名空间下的. 这样会使得多个模块能够对同一个`action`或`mutation`做操作.
`Getter`同样也是默认注册在全局的命名空间下的.

如果希望模块具有更好的`封装度`和`复用性`,可以通过添加`namespaced: true`的方式,使其成为具有命名空间的模块.
该模块下面的`getters`和`mutation`以及`action`,都会自动根据模块注册路径调整命名.

```js namespaced
const store = createStore({
  modules: {
    account: {
      namespaced: true,
      // 模块内容（module assets）
      state: () => ({ ... }), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },
      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: () => ({ ... }),
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },
        // 进一步嵌套命名空间
        posts: {
          namespaced: true,
          state: () => ({ ... }),
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```

启用的`命名空间`的`getter`和`action`会收到局部化的`getters`,`dispatch`和`commit`.

1. 在使用模块内容时,不需要再同一个模块中额外添加命名空间前缀.
2. 更换`namespaced`时,不需要修改模块内部的代码

### 如何简化`命名空间引用`的写法

[官方文档](https://vuex.vuejs.org/zh/guide/modules.html#%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0)

`createNamespacedHelpers`,`mapState`,`mapGetters`等辅助函数都有简化的写法.

### 动态注册模块

在`store`创建之后,可以使用`store.registerModule`方法注册模块.

```js
import { createStore } from "vuex";
const store = createStore({
  /* 选项 */
});
// 注册模块 `myModule`, 通过 store.state.myModule 访问
store.registerModule("myModule", {
  // ...
});
// 注册嵌套模块 `nested/myModule` 通过 store.state.nested.myModule 访问
store.registerModule(["nested", "myModule"], {
  // ...
});
```

`vuex-router-sync`插件就是通过动态注册模块将`Vue-Router`和`VueX`结合在一起,实现应用的路由状态管理.
通过`store.unregisterModule(moduleName)`的方式来动态卸载模块; **无法卸载静态模块 (store 声明的模块)**
