

## 异步组件
在开发的时候,为了减少首屏代码体积,往往会把非首屏的组件设计成异步组件,做到按需加载;
Vue支持异步组件加载的能力
```js
    Vue.component('async-example', function (resolve, reject) {
      /**
       * 这个特殊的 require 语法告诉 webpack
       * 自动将编译后的代码分割成不同的块，
       * 这些块将通过 Ajax 请求自动下载。
       */
      require(['./my-async-component'], resolve)
    })
```
Vue注册的组件,不是一个对象,而是一个`工厂函数`;这个函数有两个参数: `resolve`,`reject`;
函数内部应该是`动态请求异步组件地址`,然后通过`resolve`, 解析成`异步组件对象`

在组件化中,`createComponent`方法会判断组件是函数,所以不会调用`Vue.extend`方法,
我们传入的`Ctor`是一个函数,cid是undefined => 会使用`Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)`进行解析;

```js
    // src/core/vdom/helpers/resolve-async-component.js
    export function resolveAsyncComponent (
      factory: Function, // 组件工厂: 这里是传入的函数
      baseCtor: Class<Component>, // Vue构造函数
      context: Component // 上下文
    ): Class<Component> | void {
      /**
       * 处理了3种异步组件, 所以Vue的异步组件支持3中方式的创建
       * 异步组件有四种状态: loading resolve reject timeout
       */
      if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp
      }
      if (isDef(factory.resolved)) {
        return factory.resolved
      }
      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp
      }
      /**
       * 前面的几个if条件是针对高级组件的判断, 普通的用不到
       * 从contexts开始是普通的判断 -> 解析普通的异步组件
       */
      if (isDef(factory.contexts)) {
        // 如果处于 loading 状态
        factory.contexts.push(context)
      } else {
        const contexts = factory.contexts = [context]
        let sync = true // 设定默认同步
        // forceRender: 强制重新渲染
        const forceRender = () => {
          for (let i = 0, l = contexts.length; i < l; i++) {
            // 上下文 -> 强制更新
            contexts[i].$forceUpdate()
            /**
             * 调用了渲染vm的watch和update方法, 让watch的回调执行
             * $forceUpdate --> 强制渲染一次组件
             */
          }
        }
        const resolve = once((res: Object | Class<Component>) => {
          // 缓存 解析 ; 多个地方同时初始化一个异步组件, 仅执行一次
          factory.resolved = ensureCtor(res, baseCtor) // --> 组件对象通过Vue.extend转成构造函数
          // invoke(调用) callbacks only if this is not a synchronous resolve (同步解析)
          // (async resolves are shimmed as synchronous during(在...期间) SSR)
          // 仅在同步解析时, 调用回调函数
          // 在ssr期间, 异步解析被填充为同步解析;
          if (!sync) {
            // 转换之后, sync为false, 继而执行 forceRender 方法
            forceRender()
          }
        })
        const reject = once(reason => {
          process.env.NODE_ENV !== 'production' && warn(
            `Failed to resolve async component: ${String(factory)}` +
            (reason ? `\nReason: ${reason}` : '')
          )
          if (isDef(factory.errorComp)) {
            factory.error = true
            forceRender()
          }
        })
        // 对几种异步组件进行判断
        const res = factory(resolve, reject)
        /**
         * 执行组件工厂里面的函数
         * 发送请求, 加载异步的js文件; 获取到定义的对象 res;
         */
        if (isObject(res)) {
          if (typeof res.then === 'function') {
            /**
             * Promise异步组件
             * 因为Promise异步组件既返回了Promise对象, 也没有设定resolved值
             */
            if (isUndef(factory.resolved)) {
              res.then(resolve, reject) // 成功/失败 -> resolved/reject
            }
          } else if (isDef(res.component) && typeof res.component.then === 'function') {
            // 高级异步组件
            res.component.then(resolve, reject)
            if (isDef(res.error)) {
              factory.errorComp = ensureCtor(res.error, baseCtor)
            }
            if (isDef(res.loading)) {
              factory.loadingComp = ensureCtor(res.loading, baseCtor)
              if (res.delay === 0) {
                factory.loading = true
              } else {
                setTimeout(() => {
                  if (isUndef(factory.resolved) && isUndef(factory.error)) {
                    factory.loading = true
                    forceRender()
                  }
                }, res.delay || 200)
              }
            }
            if (isDef(res.timeout)) {
              setTimeout(() => {
                if (isUndef(factory.resolved)) {
                  reject(
                    process.env.NODE_ENV !== 'production'
                      ? `timeout (${res.timeout}ms)`
                      : null
                  )
                }
              }, res.timeout)
            }
          }
        }
        sync = false
        // 在同步解析的情况下返回
        // return in case resolved synchronously
        return factory.loading
          ? factory.loadingComp
          : factory.resolved
      }
    }
```

### 普通异步组件
```js
    Vue.component('async-example', function (resolve, reject) {
      // require 进行请求分割
      require(['./my-async-component'], resolve)
    })
```
```js
    // once方法, 在`src/shared/util.js`中定义
    export function once (fn: Function): Function {
      let called = false
      return function () {
        if (!called) {
          called = true
          fn.apply(this, arguments)
        }
      }
    }
    /**
     * 传入一个function, 返回一个function; 利用闭包节流 --> 确保 resolve/reject仅执行一次
     */
```
### Promise异步组件
```js
    Vue.component(
      'async-webpack-example',
      /**
       * webpack2.0+ 支持此类异步加载的语法糖
       * 该 `import` 函数返回一个 `Promise` 对象
       */
      () => import('./my-async-component')
    )
```
### 高级异步组件
因为异步加载组件: 需要动态加载js,有一定的网络延时,且存在失败的情况;
所以设计异步组件的时候,要设置loading和error,在合适的时机对他们进行渲染;
Vue2.3+开始支持高级异步组件
```js
    const AsyncComp = () => ({
      // 需要加载的组件。应当是一个 Promise
      component: import('./MyComp.vue'),
      // 加载中应当渲染的组件
      loading: LoadingComp,
      // 出错时渲染的组件
      error: ErrorComp,
      // 渲染加载中组件前的等待时间。默认：200ms。
      delay: 200,
      // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity
      timeout: 3000
    })
    Vue.component('async-example', AsyncComp)
```
高级异步组件的初始化逻辑和普通异步组件一样，也是执行 resolveAsyncComponent，当执行完 `res = factory(resolve, reject)`，返回值就是定义的组件对象，显然满足 else if (isDef(res.component) && typeof res.component.then === 'function') 的逻辑，接着执行 res.component.then(resolve, reject)，当异步组件加载成功后，执行 resolve，失败执行 reject。

## 异步组件加载过程
异步组件的加载是一个异步的过程; 执行的逻辑如下:
```js
    // 先判断是否定义了`error/loading`组件, 如果有的话就赋值
    if (isDef(res.error)) {
      factory.errorComp = ensureCtor(res.error, baseCtor)
    }
    if (isDef(res.loading)) {
      factory.loadingComp = ensureCtor(res.loading, baseCtor)
      // 设置等待时间
      if (res.delay === 0) {
        factory.loading = true
      } else {
        setTimeout(() => {
          if (isUndef(factory.resolved) && isUndef(factory.error)) {
            factory.loading = true
            forceRender()
          }
        }, res.delay || 200)
      }
    }
    if (isDef(res.timeout)) {
      setTimeout(() => {
        if (isUndef(factory.resolved)) {
          reject(
            process.env.NODE_ENV !== 'production'
              ? `timeout (${res.timeout}ms)`
              : null
          )
        }
      }, res.timeout)
    }
```

## 异步组件patch
在`createComponent`的逻辑中,
```js
    /**
     * 如果是第一次执行`resolveAsyncComponent`, 除了高级组件会使用 `delay 0` 创建一个loading组件
     * 其余情况均返回 undefined ;
     * 如果非高级组件, 通过 `createAsyncPlaceholder` 方法创建一个占位节点(vNode placeholder)
     */
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
    if (Ctor === undefined) { // 高阶组件不会返回undefined
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
    /**
     * 当执行 forceRender 的时候, 会重新触发这些异步组件
     * 但此时会存在旧节点, 触发patch过程; 和第一次略有不同
     */
```

## 总结

异步组件的实现方式:
  普通异步组件 --> 一次渲染
  Promise异步组件 --> 一次渲染
  高级异步组件 --> 两次渲染(loading --> resolved)
异步组件的状态:
  loading resolve reject timeout
异步组件获取成功之后, 通过 forceRender 强制重新渲染 ==> 得到异步加载的组件


## 思考: 如何通过异步组件改造我们的项目?

需要使用一个技术时, 先思考: 这个技术能给我们带来什么收益?
1. 能减少代码体积;
2. 是官方提供的一种优化策略, 主要是为了首屏加载
   * 较少首屏加载的时间, 可以做到延时加载
