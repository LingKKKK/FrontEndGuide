greedy 贪心,贪婪  [ˈɡriːdi]

[贪心算法](https://leetcode-cn.com/leetbook/detail/greedy/)

# 概述
    贪心算法是对完成一件事情的方法的描述, 贪心算法每一次都会做出当前看起来最好的选择,而不用考虑其他选择.
    可以和动态规划算法进行比较,看看少考虑了哪些子问题,为什么可以少考虑?
    每个解只要是最优的,就完成了当前的任务,这部分需要证明你出来,必须是正确的

## 贪心算法的应用场景
    解决一个问题需要很多步骤,每一步骤都有很多种选择.
    可以使用贪心算法解决的问题,每一步只需要解决一个子问题,只做一种选择.

## 贪心算法与回溯,动态规划的区别
    贪心/回溯/动态规划,都会有这样的描述: 解决问题需要多个步骤, 每一步有多种选择.
    他们的区别是:
      回溯: 需要记录每一个步骤, 每一个选择, 用于回答所有具体的解的问题
      动态: 需要记录每一个步骤、所有选择的汇总值(最大/最小);
      贪心: 只需要记录与当前步骤相关的变量值(当前最优, 每次考虑一个子问题, 通常是自下而上的)

## 使用贪心算法需满足的条件
    能用Greedy的条件：最优子结构、无后效性、全局最优解
    能用DP的条件：最优子结构、无后效性
    --
    能用Greedy解的 == 能用DP解
    能用DP解的 != 能用Greedy解

# 分发饼干的问题
  假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
  对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
  举例:
    输入: g = [1,2], s = [1,2,3]
    输出: 2
  解释:
    你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
    你拥有的饼干数量和尺寸都足以让所有孩子满足。
    所以你应该输出2.
```ts
  function getContentChildren(g, s) {
    g.sort((a, b) => return a - b) // 格式化人员
    s.sort((a, b) => return a - b) // 格式化饼干
    let numOfChildren = g.length
    let numOfCookie = s.length
    let count = 0 // 满足的人数
    for (let i = 0, j = 0; i < numOfChildren && j < numofCookie; i++, j++) {
      // 对双数组同时进行对比, 最小的饼干 满足 胃口最小的人 → 再进行下一步
      while (j < numofCookie && g[i] > s[j]) {
        j++ // 当前的饼干无法满足, 找下一个饼干
      }
      if (j < numOfChildren) {
        count++ // 当前的饼干和当前的人是最优解, 继续匹配下一个
      }
    }
  }
```

# 找零钱问题
    在柠檬水摊上，每一杯柠檬水的售价为 5 美元。
    顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
    每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
    注意，一开始你手头没有任何零钱。
    如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

    示例 1：
      输入：[5,5,5,10,20]
      输出：true
      解释：
      前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
      第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
      第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
      由于所有客户都得到了正确的找零，所以我们输出 true。

    分析: 当前顾客的付款时
         true → 客户5元 / 客户10元, 手里有5元 / 客户20元, 手里有15元
         false → 其余找不开零钱的时候
```ts
var lemonadeChange = function(bills) {
  let five = 0, ten = 0;
  for (let i = 0; i < bills.length; i++) {
    if (bills[i] === 5) five += 1;
    if (bills[i] === 10) {
      if (five === 0) return false;
      five -= 1 && ten += 1
    }
    if (bills[i] === 20) {
      if (five > 0 && ten > 0) {
        five -= 1
        ten -= 1
      } else if (ten === 0 && five > 2) {
        five -= 3;
      } else {
        return false;
      }
    }
  }
  return true;
}
```

# 区域选择问题
    优先选择活动最早的区域
## 无重叠区间
    给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
    注意:
      可以认为区间的终点总是大于它的起点。
      区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
    示例 1:
      输入: [ [1,2], [2,3], [3,4], [1,3] ]
      输出: 1
      解释: 移除 [1,3] 后，剩下的区间没有重叠。
    示例 2:
      输入: [ [1,2], [1,2], [1,2] ]
      输出: 2
      解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```ts
var eraseOverlapIntervals = function(intervals) {
  if (!intervals.length) return 0; // 如果空数组, 不做判断
  intervals.sort((a, b) => a[0] - b[0]); // 按照起点正序排列
  const n = intervals.length;
  const f = new Array(n).fill(1);
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (intervals[j][1] <= intervals[i][0]) {
        f[i] = Math.max(f[i], f[j] + 1);
      }
    }
  }
  return n - Math.max(...f);
};
```

## 最少数量的箭引爆

## 合并区间
