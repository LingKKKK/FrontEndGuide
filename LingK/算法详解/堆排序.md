[参考文档](https://blog.csdn.net/weixin_43736084/article/details/104154959)

# 介绍

`堆排序`是利用`堆`这一数据结构设计的算法. 不稳定排序, 堆排序的时间复杂度为`O(nlogn)`.

**堆排序的基本思想**
a) 将待排序的序列(数组)构建成一个大顶堆
b) 此时,整个序列的最大值就是堆顶的根节点
c) 将堆顶的根节点与最后一个节点交换,此时最大值就位于数组的末尾
d) 将剩余的 n-1 个元素重新构建成一个堆
e) 重复步骤 2-5,直到排序完成
_在构建的过程中,数组的内容逐渐在减少,最后会得到一个有序的数列_

**堆排序的思路**
a) 将无序的序列构建成一个堆,根据升序和降序的需求选择大顶堆或者小顶堆
b) 将堆顶元素与末位进行交换,将元素`下沉`到数组末端
c) 重新调整结构,使其满足`堆`的结构,反复执行`下沉`操作,知道排序完成

# js 实现堆排序

```js
// 堆排序代码实现
function heapSort(array) {
  let length = array.length;
  // 如果不是数组活着数组长度小于等于1 ，直接放回 不需要排序
  if (!Array.isArray(array) || length <= 1) return;
  buildMaxHeap(array); // 将传入的数组建立为大顶堆
  // 每次循环 将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆
  for (let i = length - 1; i > 0; i--) {
    swap(array, 0, i);
    adjustMaxHeap(array, o, i); // 将剩下的元素重新构建为大顶堆
  }
  return array;
}
function adjustMaxHeap(array, index, heapSize) {
  let iMax, iLeft, iRight;
  while (true) {
    iMax = index; // 保存最大的索引值
    iLeft = 2 * index + 1; //获取左子元素的索引
    iRight = 2 * index + 2; // 获取右子元素的索引
    // 如果左子元素存在，且左子元素，大于最大值，则更新最大值索引
    if (iLeft < heapSize && array[iMax] < array[iLeft]) {
      iMax = iLeft;
    }
    // 如果右子元素存在。且右子元素大于最大值，则更新最大值索引
    if (iRight < heapSize && array[iMax] < array[iRight]) {
      iMax = iRight;
    }
    //   如果最大的元素被更新了 则交换位置，使得父节点大于他的子节点，同时将索引值更新为被替换的值，继续检查他的子树
    if (iMax !== index) {
      swap(array, index, iMax);
      index = iMax;
    } else {
      //如果未被更新，说明该字数满足大顶堆的要求，退出循环
      break;
    }
  }
}
//构建大顶堆
function buildMaxHeap(array) {
  let length = array.length,
    iParent = parseInt(length >> 1) - 1; // 获取最后一个非叶子点的元素

  for (let i = iParent; i >= 0; i--) {
    adjustMaxHeap(array, i, length); //循环调整每一个子树，使其满足大顶堆的要求
  }
}
// 交换数组中两个元素的位置
function swap(array, i, j) {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
```
