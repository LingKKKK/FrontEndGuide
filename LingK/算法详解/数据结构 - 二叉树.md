# 二叉树的概念

**二叉树（binary tree）** 是指树中` 结点的度``不大于2 `的`有序`树,它是一种最简单且最重要的树。

二叉树的递归定义为:
二叉树是一棵空树,或者是一棵由一个根节点和两棵互不相交的,分别称作根的左子树和右子树组成的非空树;(复合)
左子树和右子树又同样都是二叉树

**满二叉树**: 二叉树的每层的度都为 2; 层数为 n,且结点总数是 2ⁿ - 1 ,则它就是满二叉树
**完全二叉树**: 对于一些节点,我们按照二叉树的排列规则,从左到右的依次向下排列,中间不能有空位,就叫完全二叉树
将二叉树,从上到下,从左到右的顺序排列,每个节点中间无间隔就是完全二叉树,左上的权重更高.
_满二叉树一定是完全二叉树,而完全二叉树不一定是满二叉树_

**完全二叉树的特性**

- 若 `i>0`,双亲序号:(i-1)/2; i=0, i 为根结点编号,无双亲结点
- 若 `2i+1<n`,左孩子序号:2i+1,否则无左孩子
- 若 `2i+2<n`,右孩子序号:2i+2,否则无右孩子

# 二叉树的存储

存储的方式分为两种:

1. 顺序存储; 适合完全二叉树
2. 类链表存储; 适合任意二叉树

```js 类链表存储: 通过一个一个的节点引用来关联数据,常用于二叉三叉树
// 孩子表示法
class Node {
  int val;        // 数据域
  Node left;      // 左孩子的引用，常常代表左孩子为根的整棵左子树
  Node right;     // 右孩子的引用，常常代表右孩子为根的整棵右子树
}
// 孩子双亲表示法
class Node {
  int val;        // 数据域
  Node left;      // 左孩子的引用，常常代表左孩子为根的整棵左子树
  Node right;     // 右孩子的引用，常常代表右孩子为根的整棵右子树
  Node parent;    // 当前节点的根节点
}
```

# 二叉树遍历

## 前序/中序/后序

在遍历二叉树时,如果没有约定,遍历出的结果会比较乱,因为不知道遍历的顺序.
`N`代表根节点
`L`代表左子树
`R`代表右子树
则根据遍历根节点的先后次序有以下遍历方式:

- **NLR**: 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点--->根的左子树--->根的右子树。
- **LNR**: 中序遍历(Inorder Traversal)——根的左子树--->根节点--->根的右子树。
- **LRN**: 后序遍历(Postorder Traversal)——根的左子树--->根的右子树--->根节点。

[参考](https://blog.csdn.net/m0_51601105/article/details/121069707)

## 层序遍历

自上而下，自左至右逐层访问树的结点; 类似广度优先搜索,先横向再纵向
