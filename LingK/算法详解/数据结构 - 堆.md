[参考文档](https://blog.csdn.net/m0_51601105/article/details/121286334)

# 堆 heap

在`完全二叉树`的基础上,进行了一些元素调整
**堆的特性** 1.堆中某个节点的值,总是不大于/不小于其父节点的值. 2.堆一定是完全二叉树
**堆的可视化操作**: : https://visualgo.net/zh/heap

# 堆的创建

1.堆的向下调整
对于集合 { 27,15,19,18,28,34,65,49,25,37 } 中的数据，如果将其创建成堆呢?

```排列成堆 (以小顶堆为例)
            27
          /   \
        15     19
       /  \   /  \
      18  28 34  65
     /  \   \
    49  25  37
```

从初步的排序中,可以看出,除了根节点,其他节点的排序都是符合小顶堆要求的.只需要修改根节点的值,即可完成堆的创建.

- 让 parent 标记需要调整位置的节点. child 标记 parent 的左节点 (如果有子节点,那必然有左子节点)
- 如果 parent 左子节点存在
  - parent 右子节点是否存在, 找到左右子节点中较小的节点, 用 child 进行标记
  - 将 parent 与较小的子节点做比较,如果 parent 大于较小的子节点,则交换,否则不交换
    - `parent = child` `child = parent*2+1` 交换位置

**建堆的时间复杂度为`O(N)`**

# 堆的插入和删除

堆的插入:
  - 将元素放到底层空间中 (空间不够时需要扩容)
  - 将新插入的元素向上调整,直到满足堆的特性

堆的删除:
  - 将堆顶元素与堆的最后一个元素进行交换
  - 将堆的有效数据减少一个
  - 对堆顶元素进行向下调整,直到满足堆的特性

# 堆的应用

1.优先级队列的实现
  用堆作为底层数据结构,封装优先级队列
2.堆排序
  a) 建堆 (大堆/小堆)
  b) 利用堆的思想进行排序
3.[top-k的问题](https://leetcode.cn/problems/smallest-k-lcci/)
  即:求前k个最大元素/最小元素  针对数据量较少时,使用排序最为方便,但是数据量增大时,需要使用堆排序
  a) 利用数据的前k个值来建堆
    前k个最大元素 -> 建小堆
    前k个最小元素 -> 建大堆
  b) 剩余的元素,依次和堆顶进行比较,满足条件即可替换堆顶元素
4.复杂度分析
  a) 时间复杂度
    *O(nlogk)* n为数据的长度,k为维护的元素个数
  b) 空间复杂度
    *O(k)*, k为维护的元素个数
