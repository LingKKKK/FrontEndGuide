# 什么是闭包?

    1. 当函数可以记录并访问作用域时, 就产生了闭包;
    2. 闭包就是能够读取其他函数内部变量的函数, 本质上是内外函数之间连接的桥梁;
    3. 函数和, 对其周围语法环境的引用内容 捆绑在一起, 构成了闭包; [函数+引用=闭包]

    ```JavaScript
      function foo() {
        var a = 'aaa';
        function bar() {
          console.log(a);
        }
        bar()
      }
      foo();
    ```

# 作用域、作用域链

    作用域: 变量和函数的可访问范围; (作用域控制着: 变量和函数的可见性和生命周期)
    全局作用域: 在代码中均可以访问到
    局部作用域: 仅在固定的代码片段中可见
    块作用域: es6新增, if for中的{}就是块作用域

    作用域链:
      1. 保证对执行环境中所有可访问变量和函数 进行有序的访问;
      2. 符合就近原则, 从最近的作用域查找起, 一直查询到全局作用域; 逐层向上查询

# 递归

    1. 函数在函数体内会调用自身
    2. 一定要有终止条件

    尾递归: 在结尾处进行调用, 防止了调用栈溢出的问题

# 防抖 / 节流

    debounce和throttle都是为了限制函数执行的频率,从而优化了因触发频率过高导致的"相应速度跟不上刷新频率的问题";
    避免了出现卡顿,假死,延迟的现象;

    1. 函数防抖 (debounce) 触发高频事件之后的n秒内, 函数只执行一次, 如果在n秒内事件再次触发, 就重新计时;
       浏览器缩放 | 输入框连续输入
    2. 函数节流 (throttle) 高频事件触发, 但是在n秒内只会执行一次, 节流会稀释事件的执行频率;
       连续点击 | 连续请求

    ```javascript
      // throttle
      function throttle(fn, delay) {
        let toggle = true; // 通过闭包保存一个标记
        return function () {
          if (!toggle) return;
          toggle = false;
          setTimeout(() => {
            fn.apply(this, arguments);
            toggle = true;
          }, delay)
        }
      }
      function handle(e) {
        // todo
      }
      window.addEventListener('click', throttle(handle, 500));

      // debounce
      function debounce(fn, delay) {
        var timer = null;
        return function() {
          clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(this, arguments);
          }, delay);
        }
      }
      function handle(e) {
        // todo
      }
      window.addEventListener('resize', debounce(handle, 500));
    ```

    总结:
      1. debounce: 将多次操作合并为一个操作, 原理是维护一个计时器, 规定在delay之后触发函数, 如果在delay之内激活, 就销毁计时器,重新计算, 这样只有最后一次可以成功的执行;
      2. throttle: 函数执行完毕之前, 组织函数再次执行; 原理就是通过一个开关进行控制;
