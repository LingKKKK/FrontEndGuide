# 重构和优化的注意事项
  1. 重构是减缓代码腐化的有效手段
     软件一般都有较长的生命周期. 即使当初的设计和框架合理, 但是随着版本升级迭代

# 如何保证安全性

# 如何验证

# 如何测试

# 如果回滚

# 解决的问题
  1.体现权限是怎么来的? 以及权限的基本逻辑
    原子权限: 掩码的定义关系/逻辑 (希望把设计的意图表示出来)

    atomicCode.js (基础)
      要素: 0b1 掩码/禁止码 ID/field/key/desc  id%1000 >> 左移位数
      # 能力:判断是否具有某种权限的能力
      定义-关系-能力
    basicCode.js (所有业务的基础)
      compose AtomicCode.js 得来
      函数反应映射关系 ComposeAtomicCode => return basicCodeSet
      反映了从何而来; 数据来源
      accessMode拿到具有的原子权限列表 'value:value:value'
      能力:判断是否具有某种权限的能力
      通过 & 运算, 判断是否具有某种能力
      定义-关系-能力 掩码/禁止码 ID/field/key/desc
    PresetCode.js (和业务挂钩)
      list数据结构, 定义了所有的预置权限(标准权限)
      作用: 授权 列表渲染你
           鉴权

    Preset:edit  111111111111   A
    Compreview   0000000000001  B
      (C = (A & b))  == A
    以上是理论基础;

    将理论基础 升级成现有的代码;

  将理论核心替换, 对外暴露的样子保持一致, 这样比较符合重构的节奏;
  把自己想象成第三方, 不能要求使用者大范围的修改api

  重构如果有一段时间需要停服务, 这个不符合重构的期望;



//  12 11 不能重复出现 需要体现依赖ATOMIC的关系
//  padStart补全字符串 12位, 不需要转数组再转字符串
//  通过码将关系连接, 并非名称 字段等
//  强制要求3 4进行合并, 并非遍历得到内容;;; 原理上的体现,搭积木的形式
//  结构化的内容可以forEach, 非结构化的内容必须通过定义得来
//  可扩展性
//  Atomic -> Basic
//  重构的目的是: 理解和还原
//  0-4095进行枚举, 统计差异数量, 如果数量为0, 就可以完全替代; 枚举完毕即可替换方法
//  保证公有使用的时候可以完全扩展

//  新旧方法都可以进行暴露
